<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Card Game Prototype</title>
    <style>
        /* é»’ã„ç”»é¢ï¼ˆã‚³ãƒ³ã‚½ãƒ¼ãƒ«ï¼‰é¢¨ã®ãƒ‡ã‚¶ã‚¤ãƒ³ */
        body { background-color: #1e1e1e; color: #d4d4d4; font-family: 'Consolas', 'Monaco', monospace; margin: 0; padding: 20px; display: flex; flex-direction: column; height: 90vh; }
        #game-log { flex: 1; overflow-y: auto; white-space: pre-wrap; margin-bottom: 10px; border: 1px solid #444; padding: 10px; }
        #input-area { display: flex; gap: 10px; }
        #command-input { flex: 1; background: #252526; color: white; border: 1px solid #555; padding: 10px; font-size: 16px; }
        button { background: #0e639c; color: white; border: none; padding: 10px 20px; cursor: pointer; font-size: 16px; }
        button:hover { background: #1177bb; }
        .p1 { color: #9cdcfe; } /* é’ã£ã½ã„è‰² */
        .p2 { color: #ce9178; } /* èµ¤ã£ã½ã„è‰² */
        .system { color: #6a9955; } /* ç·‘ã£ã½ã„è‰² */
    </style>
</head>
<body>

    <div id="game-log"></div>
    
    <div id="input-area">
        <input type="text" id="command-input" placeholder="ã“ã“ã«å…¥åŠ›ã—ã¦Enter..." autocomplete="off">
        <button onclick="submitInput()">é€ä¿¡</button>
    </div>

<script>
// ==========================================
// ãƒ–ãƒ©ã‚¦ã‚¶ç”¨ å…¥å‡ºåŠ›ã‚·ã‚¹ãƒ†ãƒ  (Node.jsã®ä»£ã‚ã‚Š)
// ==========================================
const logDiv = document.getElementById('game-log');
const inputField = document.getElementById('command-input');
let inputResolver = null;

// ç”»é¢ã«æ–‡å­—ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
function print(text, className = '') {
    const span = document.createElement('div');
    span.textContent = text;
    if (className) span.className = className;
    logDiv.appendChild(span);
    logDiv.scrollTop = logDiv.scrollHeight; // è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›ã‚’å¾…ã¤é–¢æ•° (Node.jsã®askç›¸å½“)
function ask(question) {
    print(question, 'system');
    return new Promise(resolve => {
        inputResolver = resolve; // å…¥åŠ›å¾…ã¡çŠ¶æ…‹ã«ã™ã‚‹
        inputField.focus();
    });
}

// é€ä¿¡ãƒœã‚¿ãƒ³ã‚„Enterã‚­ãƒ¼ã§å‘¼ã°ã‚Œã‚‹é–¢æ•°
function submitInput() {
    if (inputResolver) {
        const val = inputField.value;
        print(`> ${val}`); // å…¥åŠ›å†…å®¹ã‚’è¡¨ç¤º
        inputField.value = '';
        const resolve = inputResolver;
        inputResolver = null;
        resolve(val); // å¾…ã£ã¦ã„ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«å…¥åŠ›ã‚’æ¸¡ã™
    }
}

// Enterã‚­ãƒ¼å¯¾å¿œ
inputField.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') submitInput();
});


// ==========================================
// ã“ã“ã‹ã‚‰ä¸‹ã¯ ã‚²ãƒ¼ãƒ ã®ãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—)
// ==========================================

const CARD_TYPE = {
    BLANK: 'blank',
    SKILL: 'skill',
    JOKER: 'joker',
    SPELL_BREAK: 'break'
};

const CARD_MODE = {
    ATTACK: 'attack',
    DEFENSE: 'defense'
};

class Card {
    constructor(type) {
        this.type = type;
        this.value = 0;
        this.mode = CARD_MODE.ATTACK;
        this.initValue();
    }

    initValue() {
        if (this.type === CARD_TYPE.BLANK || this.type === CARD_TYPE.SKILL) {
            this.value = Math.floor(Math.random() * 13) + 1;
        } else if (this.type === CARD_TYPE.JOKER) {
            this.value = 14;
        } else if (this.type === CARD_TYPE.SPELL_BREAK) {
            this.value = 0;
        }
    }

    toString() {
        let modeStr = (this.type === CARD_TYPE.BLANK) ? `(${this.mode === CARD_MODE.ATTACK ? 'æ”»' : 'é˜²'})` : '';
        let valStr = (this.type === CARD_TYPE.SPELL_BREAK) ? "âˆ" : this.value;
        return `[${this.type.toUpperCase()}${modeStr}:${valStr}]`;
    }
}

class StatusEffect {
    constructor(name, type, value1, value2 = null) {
        this.name = name;
        this.type = type;
        this.val1 = value1;
        this.val2 = value2;
    }
    onTurnEnd(owner) {
        if (this.name === 'æ­»æ¯’') {
            const damage = 2;
            print(`  â˜ ï¸ [æ¯’] ${owner.name}ã«${damage}ãƒ€ãƒ¡ãƒ¼ã‚¸ (æ®‹ã‚¹ã‚¿ãƒƒã‚¯:${this.val1 - 1})`);
            owner.receiveDamage(damage);
            this.val1 -= 1;
        }
    }
    onTakeDamage(owner, damageAmount) {
        if (this.name === 'è² å‚·' && this.val2 > 0) {
            print(`  ğŸ©¸ [è² å‚·] è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸ ${this.val1}! (æ®‹å›æ•°:${this.val2 - 1})`);
            owner.hp -= this.val1;
            this.val2 -= 1;
        }
    }
    isExpired() {
        if (this.name === 'æ­»æ¯’') return this.val1 <= 0;
        if (this.name === 'è² å‚·') return this.val2 <= 0;
        return false;
    }
}

const CHARACTERS = {
    berserker: {
        name: "ãƒãƒ¼ã‚µãƒ¼ã‚«ãƒ¼",
        maxHp: 20,
        scMax: 0,
        jkpCost: 8,
        passive: (player, eventType, data) => {
            if (eventType === 'attack_hit' && data.card.type === CARD_TYPE.BLANK) {
                print(`  ğŸ”¥ [ãƒ‘ãƒƒã‚·ãƒ–] é—˜äº‰æœ¬èƒ½: JKP+1`);
                player.jkp += 1;
            }
        },
        skillEffect: (myself, opponent, cardValue) => {
            print(`  âš”ï¸ [ã‚¹ã‚­ãƒ«] åŒæ’ƒ!`);
            opponent.receiveDamage(cardValue);
            opponent.receiveDamage(cardValue);
            opponent.addStatus(new StatusEffect('è² å‚·', 'debuff', 1, 1));
        },
        jokerEffect: (myself, opponent) => {
            print(`  ğŸ‘¹ [JOKER] æ€ªåŠ›ä¹±ç¥!`);
            opponent.addStatus(new StatusEffect('è² å‚·', 'debuff', 1, 20));
            opponent.receiveDamage(10);
        }
    },
    venom: {
        name: "ãƒ´ã‚§ãƒãƒ ",
        maxHp: 36,
        scMax: 0,
        jkpCost: 0,
        passive: (player, eventType, data) => {
            if (eventType === 'attack_hit' && data.card.type === CARD_TYPE.BLANK) {
                print(`  ğŸ§ª [ãƒ‘ãƒƒã‚·ãƒ–] æ¯’çˆª: æ­»æ¯’+2`);
                data.opponent.addStatus(new StatusEffect('æ­»æ¯’', 'debuff', 2));
            }
        },
        skillEffect: (myself, opponent, cardValue) => {
            print(`  ğŸŒ«ï¸ [ã‚¹ã‚­ãƒ«] ãƒã‚¤ã‚ºãƒ³ãƒŸã‚¹ãƒˆ!`);
            opponent.addStatus(new StatusEffect('æ­»æ¯’', 'debuff', 5));
        },
        jokerEffect: (myself, opponent) => {
            print(`  ğŸ’‰ [JOKER] ã‚ªãƒ¼ãƒãƒ¼ãƒ‰ãƒ¼ã‚º!`);
            let poison = opponent.statusList.find(s => s.name === 'æ­»æ¯’');
            if (poison) {
                let dmg = Math.floor(poison.val1 / 2);
                let heal = Math.floor(dmg / 2);
                print(`  æ¯’å¸å: ${dmg}ãƒ€ãƒ¡ä¸ãˆã€${heal}å›å¾©`);
                opponent.receiveDamage(dmg);
                myself.hp += heal;
            }
        }
    }
};

class Player {
    constructor(charKey) {
        this.charData = CHARACTERS[charKey];
        this.name = this.charData.name;
        this.hp = this.charData.maxHp;
        this.jkp = 0;
        this.hand = [];
        this.statusList = [];
    }

    drawHand() {
        this.hand = [];
        this.hand.push(new Card(CARD_TYPE.BLANK));
        this.hand.push(new Card(CARD_TYPE.BLANK));
        this.hand.push(new Card(CARD_TYPE.SKILL));
        this.hand.push(new Card(CARD_TYPE.JOKER));
        this.hand.push(new Card(CARD_TYPE.SPELL_BREAK));
    }

    addStatus(newEffect) {
        let existing = this.statusList.find(e => e.name === newEffect.name);
        if (existing) {
            if (existing.name === 'æ­»æ¯’') existing.val1 += newEffect.val1;
            else if (existing.name === 'è² å‚·') this.statusList.push(newEffect);
        } else {
            this.statusList.push(newEffect);
        }
    }

    receiveDamage(amount) {
        this.statusList.forEach(s => s.onTakeDamage(this, amount));
        this.statusList = this.statusList.filter(s => !s.isExpired());
        this.hp -= amount;
        if (this.hp < 0) this.hp = 0;
        print(`  > ${this.name} HP: ${this.hp}`);
    }
}

class Game {
    constructor(p1Key, p2Key) {
        this.p1 = new Player(p1Key);
        this.p2 = new Player(p2Key);
        this.turn = 1;
    }

    startTurn() {
        print(`\n================================`, 'system');
        print(`=== ã‚¿ãƒ¼ãƒ³ ${this.turn} é–‹å§‹ ===`, 'system');
        print(`================================`, 'system');
        print(`[P1] ${this.p1.name} (HP:${this.p1.hp}, JKP:${this.p1.jkp})`, 'p1');
        print(`[P2] ${this.p2.name} (HP:${this.p2.hp}, JKP:${this.p2.jkp})`, 'p2');
        this.p1.drawHand();
        this.p2.drawHand();
    }

    isCardPlayable(player, cardIndex) {
        const card = player.hand[cardIndex];
        if (!card) return false;
        
        if (card.type === CARD_TYPE.JOKER && player.jkp < player.charData.jkpCost) {
            print(`ğŸš« JKPä¸è¶³(${player.jkp}/${player.charData.jkpCost})ã®ãŸã‚ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼ã‚’é¸æŠã§ãã¾ã›ã‚“ã€‚`);
            return false;
        }
        return true;
    }

    resolveBattle(p1CardIndex, p2CardIndex) {
        const c1 = this.p1.hand[p1CardIndex];
        const c2 = this.p2.hand[p2CardIndex];

        print(`\nâš”ï¸ ãƒãƒƒãƒçµæœ:`);
        print(`  ${this.p1.name}: ${c1.toString()}`, 'p1');
        print(`  ${this.p2.name}: ${c2.toString()}`, 'p2');

        let winner = null;
        let isBreakVictory = false;

        if (c1.type === CARD_TYPE.SPELL_BREAK && c2.type === CARD_TYPE.JOKER) winner = this.p1;
        else if (c2.type === CARD_TYPE.SPELL_BREAK && c1.type === CARD_TYPE.JOKER) winner = this.p2;
        else if (c1.type === CARD_TYPE.SPELL_BREAK) { winner = this.p2; isBreakVictory = true; }
        else if (c2.type === CARD_TYPE.SPELL_BREAK) { winner = this.p1; isBreakVictory = true; }
        else {
            if (c1.value > c2.value) winner = this.p1;
            else if (c2.value > c1.value) winner = this.p2;
            else {
                const p1Def = (c1.mode === CARD_MODE.DEFENSE);
                const p2Def = (c2.mode === CARD_MODE.DEFENSE);
                if (p1Def && !p2Def) winner = this.p1;
                else if (!p1Def && p2Def) winner = this.p2;
                else winner = null;
            }
        }

        if (winner) {
            const loser = (winner === this.p1) ? this.p2 : this.p1;
            const winCard = (winner === this.p1) ? c1 : c2;
            
            print(`ğŸ… å‹è€…: ${winner.name}`, 'system');

            if (isBreakVictory) {
                print(`  âš¡ ã‚¹ãƒšãƒ«ãƒ–ãƒ¬ã‚¤ã‚¯å¤±æ•—ï¼ ${loser.name}ã¯è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒå¢—åŠ (1)ï¼`);
                loser.receiveDamage(1); 
            }

            this.applyCardEffect(winner, loser, winCard);
        } else {
            print("Draw (å¼•ãåˆ†ã‘ - ä½•ã‚‚èµ·ã“ã‚‰ãªã„)");
        }
    }

    applyCardEffect(winner, loser, card) {
        if (card.type === CARD_TYPE.BLANK && card.mode === CARD_MODE.ATTACK) {
             if (winner.charData.passive) {
                 winner.charData.passive(winner, 'attack_hit', { opponent: loser, card: card });
             }
        }

        switch (card.type) {
            case CARD_TYPE.BLANK:
                if (card.mode === CARD_MODE.ATTACK) {
                    print(`  ğŸ‘Š é€šå¸¸æ”»æ’ƒï¼ å¨åŠ›:${card.value}`);
                    loser.receiveDamage(card.value);
                } else {
                    print(`  ğŸ›¡ï¸ é˜²å¾¡æˆåŠŸï¼ (åŠ¹æœãªã—)`);
                }
                break;
            case CARD_TYPE.SKILL:
                winner.charData.skillEffect(winner, loser, card.value);
                break;
            case CARD_TYPE.JOKER:
                winner.jkp -= winner.charData.jkpCost;
                winner.charData.jokerEffect(winner, loser);
                break;
            case CARD_TYPE.SPELL_BREAK:
                print(`  âœ¨ ã‚¹ãƒšãƒ«ãƒ–ãƒ¬ã‚¤ã‚¯æˆåŠŸï¼ (åŠ¹æœãªã—)`);
                break;
        }
    }

    endTurn() {
        print(`\n--- ã‚¿ãƒ¼ãƒ³çµ‚äº†å‡¦ç† ---`);
        this.p1.jkp += 1;
        this.p2.jkp += 1;
        [this.p1, this.p2].forEach(p => {
            p.statusList.forEach(s => s.onTurnEnd(p));
            p.statusList = p.statusList.filter(s => !s.isExpired());
        });
        this.turn++;
    }

    isGameOver() {
        return this.p1.hp <= 0 || this.p2.hp <= 0;
    }
}

// --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ---
async function selectCard(player, game) {
    while (true) {
        print(`\nã€${player.name} ã®ã‚¿ãƒ¼ãƒ³ã€‘`, player === game.p1 ? 'p1' : 'p2');
        print("æ‰‹æœ­:");
        player.hand.forEach((card, index) => {
            let note = "";
            if (card.type === CARD_TYPE.JOKER && player.jkp < player.charData.jkpCost) {
                note = " (Ã— JKPä¸è¶³)";
            }
            print(`  ${index}: ${card.toString()}${note}`);
        });

        const answer = await ask(`> ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„ (0-4): `);
        const index = parseInt(answer);

        if (isNaN(index) || index < 0 || index >= player.hand.length) {
            print("âš ï¸ ç„¡åŠ¹ãªç•ªå·ã§ã™ã€‚ã‚‚ã†ä¸€åº¦å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
            continue;
        }

        if (!game.isCardPlayable(player, index)) {
            continue; 
        }

        const selectedCard = player.hand[index];
        if (selectedCard.type === CARD_TYPE.BLANK) {
            const modeAns = await ask(`> ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„ (a:æ”»æ’ƒ / d:é˜²å¾¡): `);
            if (modeAns.toLowerCase() === 'd') {
                selectedCard.mode = CARD_MODE.DEFENSE;
            } else {
                selectedCard.mode = CARD_MODE.ATTACK;
            }
        }
        return index;
    }
}

async function main() {
    print("=== ã‚«ãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ  ãƒãƒˆãƒ«ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ ===", 'system');
    print("ä¸‹ã«ã‚ã‚‹å…¥åŠ›ãƒœãƒƒã‚¯ã‚¹ã«ç•ªå·ã‚’å…¥ã‚Œã¦Enterã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚", 'system');
    
    const game = new Game('berserker', 'venom');

    while (!game.isGameOver()) {
        game.startTurn();

        // P1
        const p1Index = await selectCard(game.p1, game);
        print("--------------------------------");

        // P2
        const p2Index = await selectCard(game.p2, game);

        game.resolveBattle(p1Index, p2Index);
        
        if (game.isGameOver()) break;

        game.endTurn();
        await ask('\n[ä½•ã‹å…¥åŠ›ã—ã¦Enterã§æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã¸é€²ã‚€]');
    }

    print("\n=== ã‚²ãƒ¼ãƒ ã‚»ãƒƒãƒˆï¼ ===", 'system');
    if (game.p1.hp > 0) print(`å‹è€…: ${game.p1.name} !`, 'p1');
    else if (game.p2.hp > 0) print(`å‹è€…: ${game.p2.name} !`, 'p2');
    else print("å¼•ãåˆ†ã‘ï¼");
}

// ã‚²ãƒ¼ãƒ é–‹å§‹
main();

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Online Card Battle</title>
    <style>
        body { background-color: #202020; color: #fff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; display: flex; height: 100vh; overflow: hidden; }
        .screen { width: 100%; height: 100%; display: none; }
        .active-screen { display: flex; }
        
        /* ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ */
        #title-screen { 
            flex-direction: column; 
            justify-content: flex-start; 
            align-items: center; 
            background: radial-gradient(circle, #2b2b2b 0%, #1a1a1a 100%); 
            z-index: 200; 
            position: relative; 
            overflow-y: auto; 
            padding-top: 80px; 
            padding-bottom: 50px; 
            box-sizing: border-box;
        }
        
        h1 { font-size: 48px; margin-bottom: 10px; color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); flex-shrink: 0; }
        p.subtitle { color: #aaa; margin-bottom: 40px; font-size: 20px; flex-shrink: 0; }
        
        #char-list { display: flex; gap: 30px; flex-wrap: wrap; justify-content: center; max-width: 1200px; width: 100%; padding: 0 20px; box-sizing: border-box; }
        
        .char-select-card { width: 200px; background: #333; border: 2px solid #555; border-radius: 10px; padding: 15px; cursor: pointer; transition: all 0.3s; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.5); display: flex; flex-direction: column; justify-content: space-between; flex-shrink: 0; }
        .char-select-card:hover { transform: translateY(-10px); border-color: #00bcd4; background: #3a3a3a; }
        .char-icon { font-size: 40px; margin-bottom: 10px; }
        .char-name { font-size: 20px; font-weight: bold; margin-bottom: 5px; color: #fff; }
        .char-stats { font-size: 13px; color: #ccc; text-align: left; margin-top: 10px; line-height: 1.5; }

        /* æ¥ç¶šäººæ•°è¡¨ç¤º */
        #online-counter {
            position: fixed; 
            top: 20px; left: 20px; font-size: 18px; color: #00bcd4;
            background: rgba(0, 0, 0, 0.6); padding: 8px 15px; border-radius: 20px;
            border: 1px solid #00bcd4; display: flex; align-items: center; gap: 8px;
            z-index: 210;
        }
        .live-indicator { width: 10px; height: 10px; background-color: #00ff00; border-radius: 50%; box-shadow: 0 0 8px #00ff00; }

        /* ã‚²ãƒ¼ãƒ ç”»é¢ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        #game-area { flex: 7; display: flex; flex-direction: column; border-right: 2px solid #444; background: radial-gradient(circle at center, #2a2a2a, #1a1a1a); position: relative; }
        
        /* ãƒ­ã‚°ã‚¨ãƒªã‚¢ */
        #log-area { flex: 3; background: #111; display: flex; flex-direction: column; border-left: 1px solid #333; height: 100%; }
        #log-title { padding: 10px; text-align: center; color: #888; border-bottom: 1px solid #555; background: #1a1a1a; flex-shrink: 0; }
        #logs { flex-grow: 1; overflow-y: auto; padding: 10px; font-family: 'Consolas', monospace; font-size: 14px; scroll-behavior: smooth; }
        
        /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¾ãƒ¼ãƒ³ãƒ»ã‚«ãƒ¼ãƒ‰ */
        .player-zone { flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 10px; }
        #battle-zone { flex: 1.5; border-top: 1px solid #444; border-bottom: 1px solid #444; display: flex; justify-content: center; align-items: center; gap: 40px; background-color: rgba(0,0,0,0.2); }
        .status-box { width: 80%; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; margin-bottom: 10px; text-align: center; }
        .hp-bar-bg { width: 100%; height: 15px; background: #555; border-radius: 10px; margin-top: 5px; overflow: hidden; }
        .hp-bar-fill { height: 100%; background: linear-gradient(90deg, #4caf50, #81c784); width: 100%; transition: width 0.5s ease; }
        .status-icons { margin-top: 5px; font-size: 14px; color: #ffcc00; min-height: 20px;}
        
        .hand-container { display: flex; gap: 15px; justify-content: center; perspective: 1000px; }
        .card { width: 100px; height: 140px; background: #fff; color: #000; border-radius: 8px; display: flex; flex-direction: column; justify-content: space-between; padding: 10px; box-sizing: border-box; position: relative; cursor: pointer; transition: transform 0.2s; user-select: none; }
        .card:hover { transform: translateY(-15px) scale(1.05); z-index: 10; }
        .card.disabled { filter: grayscale(100%) brightness(0.5); cursor: not-allowed; pointer-events: none; }
        
        /* ã‚«ãƒ¼ãƒ‰ç¨®åˆ¥ã”ã¨ã®è‰² */
        .card-blank { border: 2px solid #ccc; background: linear-gradient(135deg, #fff, #f0f0f0); }
        .card-skill { border: 2px solid #ffd700; background: linear-gradient(135deg, #fff, #fffde7); }
        .card-joker { border: 2px solid #9c27b0; background: linear-gradient(135deg, #f3e5f5, #e1bee7); color: #4a148c; }
        .card-break { border: 2px solid #00bcd4; background: linear-gradient(135deg, #e0f7fa, #b2ebf2); color: #006064; }
        .card-top { font-size: 18px; font-weight: bold; }
        .card-center { font-size: 32px; text-align: center; margin-top: 10px; }
        .card-name { font-size: 10px; text-align: center; color: #555; font-weight: bold; }

        /* ãƒ¢ãƒ¼ãƒ€ãƒ« */
        #modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal-content { background: #333; padding: 20px; border-radius: 10px; text-align: center; border: 1px solid #777; min-width: 300px; }
        
        /* æ±ç”¨ãƒœã‚¿ãƒ³ */
        .btn { background: #0e639c; color: white; border: none; padding: 10px 20px; margin: 5px; cursor: pointer; border-radius: 4px; font-size: 16px; }
        .btn:hover { background: #1177bb; }
        .btn-atk { background: #d32f2f; }
        .btn-def { background: #1976d2; }

        /* ãƒ­ã‚°è£…é£¾ */
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .c-p1 { color: #64b5f6; }
        .c-p2 { color: #e57373; }
        .c-sys { color: #81c784; }
        .c-dmg { color: #ffb74d; font-weight: bold; }
        
        /* ãƒ­ãƒ¼ãƒ‰è¡¨ç¤º */
        .loading-text { font-size: 20px; color: #00bcd4; margin-top: 20px; animation: blink 1.5s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* è¨­å®šãƒœã‚¿ãƒ³ */
        #btn-settings {
            position: fixed; top: 20px; right: 20px; z-index: 300;
            font-size: 30px; cursor: pointer; opacity: 0.7; transition: opacity 0.3s;
            text-shadow: 0 0 5px #000;
        }
        #btn-settings:hover { opacity: 1; transform: rotate(90deg); transition: transform 0.5s; }
        
        #settings-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none; 
            justify-content: center; align-items: center; z-index: 400;
        }
        .settings-content {
            background: #222; padding: 30px; border-radius: 10px; border: 2px solid #555;
            text-align: center; width: 300px;
        }
        .volume-control { margin: 20px 0; }
        input[type=range] { width: 100%; cursor: pointer; }
        .close-settings { margin-top: 20px; background: #555; }
    </style>
</head>
<body>
    <div id="btn-settings" onclick="toggleSettings()">âš™ï¸</div>

    <div id="settings-modal">
        <div class="settings-content">
            <h2>SETTINGS</h2>
            <div class="volume-control">
                <label for="bgm-slider">BGM Volume: <span id="vol-value">50</span>%</label>
                <br><br>
                <input type="range" id="bgm-slider" min="0" max="100" value="50" oninput="updateVolume(this.value)">
            </div>
            <button class="btn close-settings" onclick="toggleSettings()">CLOSE</button>
        </div>
    </div>

    <div id="title-screen" class="screen active-screen">
        <div id="online-counter">
            <div class="live-indicator"></div>
            <span>Online: <span id="online-count-num">-</span></span>
        </div>
        <h1>ã‚³ãƒãƒ³ãƒ‰ãƒ¼ãƒãƒˆãƒ«ï¼ï¼ï¼</h1>
        <p class="subtitle" id="status-msg">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’é¸æŠã—ã¦ãƒãƒƒãƒãƒ³ã‚°é–‹å§‹</p>
        <div id="char-list"></div>
        <div id="wait-msg" class="loading-text" style="display:none;">å¯¾æˆ¦ç›¸æ‰‹ã‚’æ¢ã—ã¦ã„ã¾ã™...</div>
    </div>
    <div id="game-screen" class="screen">
        <div id="game-area">
            <div class="player-zone">
                <div class="status-box">
                    <div id="p2-name">Opponent</div>
                    <div class="hp-bar-bg"><div id="p2-hp-bar" class="hp-bar-fill"></div></div>
                    <div id="p2-hp-text">HP: ??/??</div>
                    <div id="p2-status" class="status-icons"></div>
                    <div>JKP: <span id="p2-jkp">0 / 0</span> | SC: <span id="p2-sc">0</span></div>
                </div>
                <div class="hand-container" id="p2-hand-view" style="opacity: 0.7; transform: scale(0.8);">
                    <div class="card card-blank" style="background:#555; border-color:#777;"></div>
                    <div class="card card-blank" style="background:#555; border-color:#777;"></div>
                    <div class="card card-blank" style="background:#555; border-color:#777;"></div>
                    <div class="card card-blank" style="background:#555; border-color:#777;"></div>
                    <div class="card card-blank" style="background:#555; border-color:#777;"></div>
                </div>
            </div>
            <div id="battle-zone">
                <div style="position:absolute; color:#aaa; top: 10px;">BATTLE FIELD</div>
                <div id="p1-play-card"></div>
                <div style="font-size:30px; font-weight:bold;">VS</div>
                <div id="p2-play-card"></div>
            </div>
            <div class="player-zone">
                <div class="hand-container" id="p1-hand-view"></div>
                <div class="status-box" style="margin-top: 20px;">
                    <div id="p1-name">You</div>
                    <div class="hp-bar-bg"><div id="p1-hp-bar" class="hp-bar-fill"></div></div>
                    <div id="p1-hp-text">HP: 20/20</div>
                    <div id="p1-status" class="status-icons"></div>
                    <div>JKP: <span id="p1-jkp">0 / 0</span> | SC: <span id="p1-sc">0</span></div>
                </div>
            </div>
            <div id="modal-overlay"><div class="modal-content"><h3 id="modal-title"></h3><div id="modal-buttons"></div></div></div>
        </div>
        <div id="log-area">
            <div id="log-title">BATTLE LOG</div>
            <div id="logs"></div>
        </div>
    </div>

<script src="/socket.io/socket.io.js"></script>

<script>
// ==========================================
// éŸ³éŸ¿ç®¡ç† (BGM System)
// ==========================================
const BGM_URL = 'bgm.mp3'; 
const bgm = new Audio(BGM_URL);
bgm.loop = true; 

function initAudio() {
    const savedVol = localStorage.getItem('bgm_volume');
    const vol = savedVol !== null ? parseInt(savedVol) : 30; 
    document.getElementById('bgm-slider').value = vol;
    updateVolume(vol);
}

function updateVolume(val) {
    document.getElementById('vol-value').textContent = val;
    bgm.volume = val / 100;
    localStorage.setItem('bgm_volume', val);
}

function toggleSettings() {
    const modal = document.getElementById('settings-modal');
    modal.style.display = (modal.style.display === 'flex') ? 'none' : 'flex';
}

function startBGM() {
    bgm.play().catch(e => console.log("BGM Play Error:", e));
}

initAudio();

// ==========================================
// å®šæ•° & ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿
// ==========================================
const CARD_TYPE = { BLANK: 'blank', SKILL: 'skill', JOKER: 'joker', SPELL_BREAK: 'break' };
const CARD_MODE = { ATTACK: 'attack', DEFENSE: 'defense' };

// å…±é€šãƒ˜ãƒ«ãƒ‘ãƒ¼: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å–å¾—
const getStatusVal = (p, name) => { let s = p.statusList.find(x => x.name === name); return s ? s.val1 : 0; };

const CHARACTERS = {
    berserker: {
        id: 'berserker', name: "ãƒãƒ¼ã‚µãƒ¼ã‚«ãƒ¼", icon: "ğŸ‘¹", maxHp: 20, jkpCost: 8, scMax: 0,
        description: "æ”»æ’ƒç‰¹åŒ–å‹ã€‚<br>HPã¯ä½ã„ãŒã€é€šå¸¸æ”»æ’ƒã®å¨åŠ›ãŒé«˜ãã€ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼ã§å¼·åŠ›ãªç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚",
        passive: (p, type, data) => { if (type === 'attack_hit' && data.card.type === CARD_TYPE.BLANK) { ui.print(`ğŸ”¥ [ãƒ‘ãƒƒã‚·ãƒ–] JKP+1`); p.jkp += 1; } },
        skillEffect: (me, op, val) => { ui.print(`âš”ï¸ [ã‚¹ã‚­ãƒ«] åŒæ’ƒ!`, 'c-p1'); op.receiveDamage(2, me); op.receiveDamage(2, me); op.addStatus(new StatusEffect('è² å‚·', 'debuff', 1, 1)); },
        jokerEffect: (me, op) => { ui.print(`ğŸ‘¹ [JOKER] æ€ªåŠ›ä¹±ç¥!`, 'c-p1'); op.addStatus(new StatusEffect('è² å‚·', 'debuff', 1, 20)); op.receiveDamage(2, me); }
    },
    venom: {
        id: 'venom', name: "ãƒ´ã‚§ãƒãƒ ", icon: "ğŸ§ª", maxHp: 36, jkpCost: 4, scMax: 0,
        description: "è€ä¹…ï¼†æ¯’å‹ã€‚<br>é«˜ã„HPã‚’æŒã¡ã€ç›¸æ‰‹ã‚’å¾ã€…ã«å‰Šã‚‹ã€‚ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼ã§ç›¸æ‰‹ã®æ¯’ã‚’å¸åã—å›å¾©ã™ã‚‹ã€‚",
        passive: (p, type, data) => { if (type === 'attack_hit' && data.card.type === CARD_TYPE.BLANK) { ui.print(`ğŸ§ª [ãƒ‘ãƒƒã‚·ãƒ–] æ­»æ¯’+2`); data.opponent.addStatus(new StatusEffect('æ­»æ¯’', 'debuff', 2)); } },
        skillEffect: (me, op, val) => { ui.print(`ğŸŒ«ï¸ [ã‚¹ã‚­ãƒ«] ãƒã‚¤ã‚ºãƒ³ãƒŸã‚¹ãƒˆ!`, 'c-p2'); op.addStatus(new StatusEffect('æ­»æ¯’', 'debuff', 5)); },
        jokerEffect: (me, op) => { ui.print(`ğŸ’‰ [JOKER] ã‚ªãƒ¼ãƒãƒ¼ãƒ‰ãƒ¼ã‚º!`, 'c-p2'); let idx = op.statusList.findIndex(s => s.name === 'æ­»æ¯’'); if (idx !== -1) { let poison = op.statusList[idx]; let dmg = Math.floor(poison.val1 / 2); let heal = Math.floor(dmg / 2); ui.print(`æ¯’å¸å: ${dmg}ãƒ€ãƒ¡, ${heal}å›å¾©`, 'c-dmg'); op.receiveDamage(dmg, me); me.hp += heal; op.statusList.splice(idx, 1); } }
    },
    shicho: {
        id: 'shicho', name: "æ­»è¶", icon: "ğŸ¦‹", maxHp: 24, jkpCost: 4, scMax: 0,
        description: "ã‚³ãƒ³ãƒœç«åŠ›å‹ã€‚<br>ã€Œè¶ã€ã‚’ç›¸æ‰‹ã«æ¤ãˆä»˜ã‘ã‚‹ã€‚ã€Œè¶ã€ã¯ç›¸æ‰‹ãŒãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹ãŸã³ã«è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚",
        passive: null, 
        skillEffect: (me, op, val) => { 
            ui.print(`ğŸ¦‹ [ã‚¹ã‚­ãƒ«] æ®‹ã‚Šã—è€…ã¸å³ç²›ãªå“€æ‚¼ã‚’`, 'c-p1'); 
            let total = 10; 
            let power = (val % 9) + 1; 
            let count = total - power; 
            ui.print(`  > è¶ä»˜ä¸: å¨åŠ›${power} / å›æ•°${count}`); 
            op.addStatus(new StatusEffect('è¶', 'debuff', power, count)); 
        },
        jokerEffect: (me, op) => { ui.print(`âš°ï¸ [JOKER] è‘¬å„€`, 'c-p1'); ui.print(`  > é€šå¸¸æ”»æ’ƒ3å›`, 'c-dmg'); for(let i=0; i<3; i++) { op.receiveDamage(1, me); op.receiveDamage(1, me); } let idx = op.statusList.findIndex(s => s.name === 'è¶'); if (idx !== -1) { let butterfly = op.statusList[idx]; ui.print(`  > è¶ç‚¸è£‚! æ®‹ã‚Š${butterfly.val1}ãƒ€ãƒ¡ãƒ¼ã‚¸!`, 'c-dmg'); op.receiveDamage(butterfly.val1, me); op.statusList.splice(idx, 1); } else { ui.print(`  > è¶ã¯ã™ã¹ã¦é£›ã³å»ã£ã¦ã„ãŸ...`); } }
    },
    madan: {
        id: 'madan', name: "é­”å¼¾", icon: "ğŸ”«", maxHp: 32, jkpCost: 0, scMax: 0, 
        description: "ã‚¹ã‚¿ãƒƒã‚¯ç®¡ç†å‹ã€‚<br>é˜²å¾¡å‹åˆ©ã‚„ã‚¹ã‚­ãƒ«ã§ã€Œé­”å¼¾ã€ã‚’è£…å¡«ã—ã€æ•°ã¨åŒé‡ã®JKPã‚’æ¶ˆè²»ã—ã¦JOKERã‚’ç™ºå‹•ã™ã‚‹ã€‚",
        passive: (p, type, data) => { if (type === 'defense_win') { ui.print(`ğŸ”« [ãƒ‘ãƒƒã‚·ãƒ–] å¼¾ä¸¸è£…å¡« (é­”å¼¾+2)`); p.addStatus(new StatusEffect('é­”å¼¾', 'buff', 2)); } },
        skillEffect: (me, op, val) => {
            let bullets = getStatusVal(me, 'é­”å¼¾');
            ui.print(`ğŸ”« [ã‚¹ã‚­ãƒ«] é­”å¼¾ç™ºå°„! (è£…å¡«æ•°:${bullets})`, 'c-p1');
            op.receiveDamage(bullets * 2, me);
            let paraPower = Math.floor(bullets / 2);
            if (paraPower > 0) { ui.print(`  > éº»ç—ºä»˜ä¸ (å¨åŠ›${paraPower})`); op.addStatus(new StatusEffect('éº»ç—º', 'debuff', paraPower, 1)); }
            me.addStatus(new StatusEffect('é­”å¼¾', 'buff', 1));
        },
        jokerEffect: (me, op) => {
            let bullets = getStatusVal(me, 'é­”å¼¾');
            ui.print(`ğŸ’£ [JOKER] é­”å¼¾æƒå°„ (å¼¾æ•°:${bullets})`, 'c-p1');
            let damage = 0; let gainBullets = 0; let resetBullets = false;
            if (bullets >= 1 && bullets <= 3) { damage = bullets * 2; op.receiveDamage(damage, me); op.addStatus(new StatusEffect('éº»ç—º', 'debuff', Math.floor(bullets/2), 2)); gainBullets = 1; } 
            else if (bullets >= 4 && bullets <= 5) { damage = bullets * 3; op.receiveDamage(damage, me); op.addStatus(new StatusEffect('é»’ç‚', 'debuff', bullets)); op.addStatus(new StatusEffect('éº»ç—º', 'debuff', Math.floor(bullets/2), 2)); gainBullets = 2; } 
            else if (bullets === 6) { damage = bullets * 4; op.receiveDamage(damage, me); op.addStatus(new StatusEffect('é»’ç‚', 'debuff', 6)); op.addStatus(new StatusEffect('éº»ç—º', 'debuff', 3, 2)); gainBullets = 1; } 
            else if (bullets >= 7) { damage = bullets * 5; op.receiveDamage(damage, me); op.addStatus(new StatusEffect('é»’ç‚', 'debuff', 7)); op.addStatus(new StatusEffect('éº»ç—º', 'debuff', 7, 2)); if (op.hp > 0) { ui.print(`  > æ•µç”Ÿå­˜...åå‹•14`, 'c-dmg'); me.receiveDamage(14, me); } resetBullets = true; }
            if (resetBullets) me.addStatus(new StatusEffect('é­”å¼¾', 'buff', -bullets)); 
            else me.addStatus(new StatusEffect('é­”å¼¾', 'buff', -bullets + gainBullets));
        }
    },
    bomber: {
        id: 'bomber', name: "ãƒœãƒãƒ¼", icon: "ğŸ§¨", maxHp: 28, jkpCost: 6, scMax: 2,
        description: "è‡ªçˆ†ç‰¹æ”»å‹ã€‚<br>ãƒ‰ãƒ­ãƒ¼ã‚’å‹åˆ©ã«å¤‰ãˆã‚‹ãƒ‘ãƒƒã‚·ãƒ–ã¨ã€æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã®æ•°å€¤ã‚’13ã«ã™ã‚‹å¼·åŠ›ãªã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼ã‚’æŒã¤ã€‚",
        passive: (p, type, data) => { 
            if (type === 'attack_hit' && data.card.type === CARD_TYPE.BLANK) { ui.print(`ğŸ§¨ [ãƒ‘ãƒƒã‚·ãƒ–] ç«è–¬å›å: HP+3`); p.hp += 3; if(p.hp > p.charData.maxHp) p.hp = p.charData.maxHp; } 
        },
        skillEffect: (me, op, val) => { ui.print(`ğŸ’£ [ã‚¹ã‚­ãƒ«] è‡ªçˆ†!!`, 'c-p1'); ui.print(`  > è‡ªèº«ã«6ãƒ€ãƒ¡ãƒ¼ã‚¸`, 'c-dmg'); me.receiveDamage(6, me); ui.print(`  > ç›¸æ‰‹ã«8ãƒ€ãƒ¡ãƒ¼ã‚¸`, 'c-dmg'); op.receiveDamage(8, me); },
        jokerEffect: (me, op) => { ui.print(`âš¡ [JOKER] å¸¯é›»`, 'c-p1'); ui.print(`  > æ¬¡ã‚¿ãƒ¼ãƒ³æ•°å€¤13 & å¨åŠ›å¢—åŠ ä»˜ä¸`); me.addStatus(new StatusEffect('å¸¯é›»', 'buff', 1)); me.addStatus(new StatusEffect('å¨åŠ›å¢—åŠ ', 'buff', 6, 2)); }
    },
    sans: {
        id: 'sans', name: "ã‚µãƒ³ã‚º", icon: "â˜ ï¸", maxHp: 1, jkpCost: 7, scMax: 0,
        description: "æœ€å¼±ã®æ•µã€‚<br>HP1ã€‚é€šå¸¸æ”»æ’ƒã¯å¸¸ã«1ãƒ€ãƒ¡ã€‚ãƒ‡ãƒãƒ•ãƒ€ãƒ¡ãƒ¼ã‚¸ã§ã¯æ­»ãªãªã„(HP1ã§æ®‹ã‚‹)ã€‚é˜²å¾¡ã‚«ãƒ¼ãƒ‰ä½¿ç”¨æ™‚ã€æ•°å€¤+2(æœ€å¤§14)ã€‚",
        passive: null, // Logic is handled in Game.resolveBattle, Game.applyCardEffect, Player.receiveDamage
        skillEffect: (me, op, val) => { 
            ui.print(`â˜ ï¸ [ã‚¹ã‚­ãƒ«] ã‚¬ã‚¹ã‚¿ãƒ¼ãƒ–ãƒ©ã‚¹ã‚¿ãƒ¼!`, 'c-p1'); 
            op.receiveDamage(3, me); 
        },
        jokerEffect: (me, op) => {
            ui.print(`ğŸ¦´ [JOKER] ã‚¹ãƒšã‚·ãƒ£ãƒ«ã“ã†ã’ã`, 'c-p1');
            ui.print(`  > HPãŒ1ã«ãªã‚‹ã¾ã§é«˜é€Ÿæ”»æ’ƒ!`, 'c-dmg');
            let hits = 0;
            // ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ã®ãŸã‚æœ€å¤§30ãƒ’ãƒƒãƒˆåˆ¶é™
            while (op.hp > 1 && hits < 30) {
                op.receiveDamage(1, me);
                hits++;
            }
            ui.print(`  > è¨ˆ${hits}ãƒ’ãƒƒãƒˆ! (ç›¸æ‰‹HP: ${op.hp})`);
            ui.print(`  > è‡ªèº«ã«éº»ç—ºä»˜ä¸(1/2)`);
            me.addStatus(new StatusEffect('éº»ç—º', 'debuff', 1, 2));
        }
    }
};

// ==========================================
// é€šä¿¡ & ã‚²ãƒ¼ãƒ ç®¡ç†å¤‰æ•°
// ==========================================
const socket = io();
let myRole = ''; 
let myCharId = '';
let opponentCharId = '';
let game = null;
let opponentMoveMailbox = {}; 

socket.on('update_count', (count) => {
    document.getElementById('online-count-num').textContent = count;
});

// ==========================================
// ã‚¯ãƒ©ã‚¹å®šç¾©
// ==========================================
class Card {
    constructor(type, forcedValue = null) { 
        this.type = type; 
        this.value = 0; 
        this.mode = CARD_MODE.ATTACK; 
        this.initValue(forcedValue); 
    }
    initValue(forcedValue) {
        if (forcedValue !== null) {
            this.value = forcedValue;
        } else {
            if (this.type === CARD_TYPE.BLANK || this.type === CARD_TYPE.SKILL) this.value = Math.floor(Math.random() * 13) + 1;
            else if (this.type === CARD_TYPE.JOKER) this.value = 14;
            else if (this.type === CARD_TYPE.SPELL_BREAK) this.value = 0;
        }
    }
}

class StatusEffect {
    constructor(name, type, value1, value2 = null) { this.name = name; this.type = type; this.val1 = value1; this.val2 = value2; }
    
    // æ”»æ’ƒã‚’ä¸ãˆãŸæ™‚ã®è£œæ­£ï¼ˆãƒœãƒãƒ¼ã®ãƒãƒ•ç”¨ï¼‰
    onDealDamage(owner, damageAmount) {
        if (this.name === 'å¨åŠ›å¢—åŠ ') {
            ui.print(`ğŸ’ª [å¨åŠ›å¢—åŠ ] ãƒ€ãƒ¡ãƒ¼ã‚¸+${this.val1}!`, 'c-dmg');
            return damageAmount + this.val1;
        }
        return damageAmount;
    }

    // æ”»æ’ƒã‚’å—ã‘ãŸæ™‚ã®è£œæ­£
    onTakeDamage(owner, damageAmount, attacker) {
        if (this.name === 'ãƒ–ãƒ¬ã‚¤ã‚¯åå‹•') { ui.print(`âš¡ [ãƒ–ãƒ¬ã‚¤ã‚¯åå‹•] è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸+1`, 'c-dmg'); return damageAmount + 1; }
        if (this.name === 'è² å‚·' && this.val2 > 0) { ui.print(`ğŸ©¸ [è² å‚·] è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸ ${this.val1}!`, 'c-dmg'); owner.hp -= this.val1; this.val2 -= 1; }
        if (this.name === 'è¶' && damageAmount > 0) { ui.print(`ğŸ¦‹ [è¶] è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸ ${this.val1}!`, 'c-dmg'); this.val2 -= 1; return damageAmount + this.val1; }
        return damageAmount;
    }

    onTurnEnd(owner) {
        // ãƒ‡ãƒãƒ•ãƒ€ãƒ¡ãƒ¼ã‚¸ã®sourceã¯nullã¨ã—ã¦æ¸¡ã™
        if (this.name === 'æ­»æ¯’') { const dmg = 2; ui.print(`â˜ ï¸ [æ­»æ¯’] ${owner.name}ã«${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸`, 'c-dmg'); owner.receiveDamage(dmg, null); this.val1 -= 1; }
        if (this.name === 'å¨åŠ›å¢—åŠ ') { this.val2 -= 1; }
        if (this.name === 'é»’ç‚') { 
            const dmg = this.val1; 
            ui.print(`ğŸ”¥ [é»’ç‚] ${owner.name}ã«${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸`, 'c-dmg'); 
            owner.receiveDamage(dmg, null); 
            this.val1 = Math.floor(this.val1 / 2); 
        }
    }

    isExpired() {
        if (this.name === 'æ­»æ¯’') return this.val1 <= 0;
        if (this.name === 'è² å‚·') return this.val2 <= 0;
        if (this.name === 'ãƒ–ãƒ¬ã‚¤ã‚¯åå‹•') return true;
        if (this.name === 'è¶') return this.val2 <= 0;
        if (this.name === 'å¨åŠ›å¢—åŠ ') return this.val2 <= 0;
        if (this.name === 'å¸¯é›»') return false; 
        if (this.name === 'é­”å¼¾') return this.val1 < 0; 
        if (this.name === 'é»’ç‚') return this.val1 <= 0;
        if (this.name === 'éº»ç—º') return this.val2 <= 0;
        return false;
    }
}

class Player {
    constructor(charKey, isMe) {
        this.charData = CHARACTERS[charKey];
        this.name = this.charData.name;
        this.hp = this.charData.maxHp;
        this.jkp = 0; this.sc = 0;
        this.hand = []; this.statusList = [];
        this.isMe = isMe;
    }
    drawHand() {
        this.hand = [];
        this.hand.push(new Card(CARD_TYPE.BLANK));
        this.hand.push(new Card(CARD_TYPE.BLANK));
        this.hand.push(new Card(CARD_TYPE.SKILL));
        this.hand.push(new Card(CARD_TYPE.JOKER));
        this.hand.push(new Card(CARD_TYPE.SPELL_BREAK));

        // ãƒœãƒãƒ¼: å¸¯é›»ãƒã‚§ãƒƒã‚¯
        const chargeIdx = this.statusList.findIndex(s => s.name === 'å¸¯é›»');
        if (chargeIdx !== -1) {
            ui.print(`âš¡ ${this.name}ã¯å¸¯é›»ã—ã¦ã„ã‚‹ï¼(å…¨æ•°å€¤13)`);
            this.hand.forEach(c => {
                if (c.type === CARD_TYPE.BLANK || c.type === CARD_TYPE.SKILL) {
                    c.value = 13;
                }
            });
            this.statusList.splice(chargeIdx, 1);
        }

        // éº»ç—ºãƒã‚§ãƒƒã‚¯
        let mahiIdx = this.statusList.findIndex(s => s.name === 'éº»ç—º');
        if (mahiIdx !== -1) {
            let mahi = this.statusList[mahiIdx];
            ui.print(`âš¡ ${this.name}ã¯éº»ç—ºã—ã¦ã„ã‚‹ (æ•°å€¤-${mahi.val1})`);
            this.hand.forEach(c => {
                if (c.type === CARD_TYPE.BLANK || c.type === CARD_TYPE.SKILL) {
                    c.value = Math.max(1, c.value - mahi.val1);
                }
            });
            mahi.val2 -= 1; // ã‚¿ãƒ¼ãƒ³çµŒé
        }
    }
    addStatus(ef) {
        let exist = this.statusList.find(e => e.name === ef.name);
        if (exist) {
            if (exist.name === 'æ­»æ¯’') exist.val1 += ef.val1;
            else if (exist.name === 'è² å‚·') { exist.val1 += ef.val1; exist.val2 += ef.val2; }
            else if (exist.name === 'è¶') { exist.val1 += ef.val1; exist.val2 += ef.val2; ui.print(`  > è¶ãŒç¾¤ã‚Œã‚’æˆã—ãŸ (å¨${exist.val1}/æ®‹${exist.val2})`); }
            else if (exist.name === 'å¨åŠ›å¢—åŠ ') { exist.val1 = ef.val1; exist.val2 = ef.val2; }
            else if (exist.name === 'é­”å¼¾') { 
                exist.val1 += ef.val1; 
                if(exist.val1 < 0) exist.val1 = 0;
                if(exist.val1 > 7) exist.val1 = 7;
                ui.print(`  > é­”å¼¾è£…å¡«æ•°: ${exist.val1}`);
            }
            else if (exist.name === 'é»’ç‚') { exist.val1 += ef.val1; }
            else if (exist.name === 'éº»ç—º') { exist.val1 = Math.max(exist.val1, ef.val1); exist.val2 += ef.val2; }
        } else {
            if (ef.name === 'é­”å¼¾' && ef.val1 <= 0) return;
            this.statusList.push(ef);
        }
    }
    receiveDamage(amount, source) {
        let finalAmount = amount;
        
        // æ”»æ’ƒå´ã®ãƒãƒ•å‡¦ç†
        if (source) {
            source.statusList.forEach(s => { 
                if(s.onDealDamage) finalAmount = s.onDealDamage(source, finalAmount); 
            });
        }

        // é˜²å¾¡å´ã®ãƒ‡ãƒãƒ•å‡¦ç†
        [...this.statusList].forEach(s => { finalAmount = s.onTakeDamage(this, finalAmount, source); });
        
        // --- ã‚µãƒ³ã‚ºå›ºæœ‰ãƒ‘ãƒƒã‚·ãƒ–: ãƒ‡ãƒãƒ•ãƒ€ãƒ¡ãƒ¼ã‚¸è€æ€§ ---
        if (this.charData.id === 'sans' && source === null) {
            // sourceãŒnullã®å ´åˆã¯ãƒ‡ãƒãƒ•(Poison/Burn)ç­‰ã¨ã¿ãªã™
            if (this.hp - finalAmount < 1) {
                ui.print(`â˜ ï¸ [ãƒ‘ãƒƒã‚·ãƒ–] æ±ºæ„ã§è€ãˆãŸ! (HP1)`, 'c-sys');
                this.hp = 1;
                return; // å‡¦ç†çµ‚äº†
            }
        }
        // ------------------------------------------

        this.statusList = this.statusList.filter(s => !s.isExpired());
        
        if(finalAmount < 0) finalAmount = 0;
        this.hp -= finalAmount; if (this.hp < 0) this.hp = 0;
    }
}

class Game {
    constructor(myChar, opChar) {
        if (myRole === 'p1') {
            this.p1 = new Player(myChar, true);
            this.p2 = new Player(opChar, false);
            this.p1.name = `${this.p1.charData.name} (YOU)`;
            this.p2.name = `${this.p2.charData.name} (OPPONENT)`;
        } else {
            this.p1 = new Player(opChar, false);
            this.p2 = new Player(myChar, true);
            this.p1.name = `${this.p1.charData.name} (OPPONENT)`;
            this.p2.name = `${this.p2.charData.name} (YOU)`;
        }
        this.turn = 1;
    }
    async resolveBattle(c1, c2) {
        ui.showBattleCards(c1, c2);
        ui.print(`âš”ï¸ ãƒãƒˆãƒ«åˆ¤å®š...`);
        await ui.wait(800);

        // --- ã‚µãƒ³ã‚ºå›ºæœ‰ãƒ‘ãƒƒã‚·ãƒ–: é˜²å¾¡å€¤å¢—åŠ  ---
        if (this.p1.charData.id === 'sans' && c1.mode === CARD_MODE.DEFENSE) {
            c1.value = Math.min(14, c1.value + 2);
            ui.print(`â˜ ï¸ [ãƒ‘ãƒƒã‚·ãƒ–] é˜²å¾¡å¼·åŒ–! å€¤->${c1.value}`);
        }
        if (this.p2.charData.id === 'sans' && c2.mode === CARD_MODE.DEFENSE) {
            c2.value = Math.min(14, c2.value + 2);
            ui.print(`â˜ ï¸ [ãƒ‘ãƒƒã‚·ãƒ–] é˜²å¾¡å¼·åŒ–! å€¤->${c2.value}`);
        }
        // -----------------------------------

        // JKPæ¶ˆè²»å‡¦ç†
        const payCost = (player, card) => {
            if (card.type !== CARD_TYPE.JOKER) return;
            let cost = player.charData.jkpCost;
            if (player.charData.id === 'madan') {
                cost = getStatusVal(player, 'é­”å¼¾'); 
            }
            ui.print(`${player.name}ã¯JKPã‚’æ¶ˆè²»! (-${cost})`);
            player.jkp -= cost;
        };

        payCost(this.p1, c1);
        payCost(this.p2, c2);

        ui.updateStatus(this.p1, this.p2);

        let winner = null;
        let p1BreakFail = false; let p2BreakFail = false;

        // ç‰¹æ®Šåˆ¤å®š
        if (c1.type === CARD_TYPE.SPELL_BREAK && c2.type === CARD_TYPE.JOKER) winner = this.p1;
        else if (c2.type === CARD_TYPE.SPELL_BREAK && c1.type === CARD_TYPE.JOKER) winner = this.p2;
        else if (c1.type === CARD_TYPE.SPELL_BREAK) { winner = this.p2; p1BreakFail = true; }
        else if (c2.type === CARD_TYPE.SPELL_BREAK) { winner = this.p1; p2BreakFail = true; }
        else if (c1.type === CARD_TYPE.JOKER && c2.type === CARD_TYPE.JOKER) {
            ui.print("âš¡ åŒæ–¹ã®å¥¥ç¾©ãŒæ¿€çªï¼", 'c-sys');
            this.applyCardEffect(this.p1, this.p2, c1);
            this.applyCardEffect(this.p2, this.p1, c2);
            return; 
        }
        else {
            if (c1.value > c2.value) winner = this.p1;
            else if (c2.value > c1.value) winner = this.p2;
            else {
                // ãƒ‰ãƒ­ãƒ¼åˆ¤å®š
                const p1IsBomber = this.p1.charData.id === 'bomber';
                const p2IsBomber = this.p2.charData.id === 'bomber';

                if (p1IsBomber && !p2IsBomber) {
                    ui.print(`ğŸ§¨ [ç¥é€Ÿ] ãƒœãƒãƒ¼ã¯åŒå€¤ã‚’åˆ¶ã™ã‚‹!`);
                    winner = this.p1;
                } else if (!p1IsBomber && p2IsBomber) {
                    ui.print(`ğŸ§¨ [ç¥é€Ÿ] ãƒœãƒãƒ¼ã¯åŒå€¤ã‚’åˆ¶ã™ã‚‹!`);
                    winner = this.p2;
                } else {
                    const p1Def = (c1.mode === CARD_MODE.DEFENSE);
                    const p2Def = (c2.mode === CARD_MODE.DEFENSE);
                    if (p1Def && !p2Def) winner = this.p1;
                    else if (!p1Def && p2Def) winner = this.p2;
                }
            }
        }
        if (p1BreakFail) this.p1.addStatus(new StatusEffect('ãƒ–ãƒ¬ã‚¤ã‚¯åå‹•', 'debuff', 1));
        if (p2BreakFail) this.p2.addStatus(new StatusEffect('ãƒ–ãƒ¬ã‚¤ã‚¯åå‹•', 'debuff', 1));

        if (winner) {
            const loser = (winner === this.p1) ? this.p2 : this.p1;
            const winCard = (winner === this.p1) ? c1 : c2;
            ui.print(`ğŸ… å‹è€…: ${winner.name}`, 'c-sys');
            if (winCard.type === CARD_TYPE.SKILL) winner.sc = winner.charData.scMax;
            
            if (winCard.mode === CARD_MODE.DEFENSE && winner.charData.passive) {
                winner.charData.passive(winner, 'defense_win', { opponent: loser, card: winCard });
            }

            this.applyCardEffect(winner, loser, winCard);
        } else {
            ui.print("Draw (å¼•ãåˆ†ã‘)", 'c-sys');
        }
    }
    applyCardEffect(winner, loser, card) {
        if (card.type === CARD_TYPE.BLANK && card.mode === CARD_MODE.ATTACK) {
             if (winner.charData.passive) winner.charData.passive(winner, 'attack_hit', { opponent: loser, card: card });
        }
        switch (card.type) {
            case CARD_TYPE.BLANK:
                if (card.mode === CARD_MODE.ATTACK) { 
                    if (winner.charData.id === 'shicho') { 
                        ui.print(`ğŸ¦‹ å¾€ã«ã—è€…ã¸ç¥è¾ã‚’ (1x2)`, 'c-dmg'); 
                        loser.receiveDamage(1, winner); loser.receiveDamage(1, winner); 
                    } 
                    // --- ã‚µãƒ³ã‚ºå›ºæœ‰: é€šå¸¸æ”»æ’ƒ1ãƒ€ãƒ¡ãƒ¼ã‚¸ ---
                    else if (winner.charData.id === 'sans') {
                        ui.print(`â˜ ï¸ [ãƒ‘ãƒƒã‚·ãƒ–] éª¨æ”»æ’ƒ (å¨åŠ›:1)`, 'c-dmg');
                        loser.receiveDamage(1, winner);
                    }
                    // -----------------------------------
                    else { 
                        ui.print(`ğŸ‘Š é€šå¸¸æ”»æ’ƒ (å¨åŠ›:2)`, 'c-dmg'); 
                        loser.receiveDamage(2, winner); 
                    }
                } else ui.print(`ğŸ›¡ï¸ é˜²å¾¡æˆåŠŸ`);
                break;
            case CARD_TYPE.SKILL: winner.charData.skillEffect(winner, loser, card.value); break;
            case CARD_TYPE.JOKER: winner.charData.jokerEffect(winner, loser); break;
            case CARD_TYPE.SPELL_BREAK: ui.print(`âœ¨ ã‚¹ãƒšãƒ«ãƒ–ãƒ¬ã‚¤ã‚¯æˆåŠŸ`); break;
        }
    }
}

// ==========================================
// GUIåˆ¶å¾¡
// ==========================================
const ui = {
    logs: document.getElementById('logs'),
    showGameScreen: () => { document.getElementById('title-screen').style.display = 'none'; document.getElementById('game-screen').style.display = 'flex'; },
    print: (text, type = '') => {
        const div = document.createElement('div'); div.textContent = text; div.className = 'log-entry ' + type;
        ui.logs.appendChild(div); ui.logs.scrollTop = ui.logs.scrollHeight;
    },
    updateStatus: (p1, p2) => {
        let me, op;
        if (p1.isMe) { me = p1; op = p2; } else { me = p2; op = p1; }
        const setText = (id, txt) => document.getElementById(id).textContent = txt;
        const setWidth = (id, percent) => document.getElementById(id).style.width = percent + '%';
        const getStatusTxt = (list) => list.map(s => {
            if(s.name === 'ãƒ–ãƒ¬ã‚¤ã‚¯åå‹•') return `âš¡åå‹•`;
            if(s.name === 'å¸¯é›»') return `âš¡å¸¯é›»`;
            if(s.name === 'å¨åŠ›å¢—åŠ ') return `ğŸ’ªå¢—å¼·(${s.val1}/${s.val2})`;
            if(s.name === 'è¶') return `ğŸ¦‹è¶(å¨${s.val1}/æ®‹${s.val2})`;
            if(s.name === 'é­”å¼¾') return `ğŸ”«é­”å¼¾(${s.val1})`;
            if(s.name === 'é»’ç‚') return `ğŸ”¥é»’ç‚(${s.val1})`;
            if(s.name === 'éº»ç—º') return `âš¡éº»ç—º(å¨${s.val1}/æ®‹${s.val2})`;
            return s.name === 'è² å‚·' ? `ğŸ©¸è² å‚·(å¨${s.val1}/æ®‹${s.val2})` : `â˜ ï¸æ­»æ¯’(${s.val1})`;
        }).join(' ');

        const getJkpText = (p) => {
             if (p.charData.id === 'madan') {
                 let bullets = getStatusVal(p, 'é­”å¼¾');
                 return `${p.jkp} / ${bullets}(å¿…è¦)`;
             }
             return `${p.jkp} / ${p.charData.jkpCost}`;
        };

        setText('p1-name', me.name); 
        setText('p1-hp-text', `${me.hp} / ${me.charData.maxHp}`); 
        setWidth('p1-hp-bar', (me.hp / me.charData.maxHp) * 100); 
        setText('p1-jkp', getJkpText(me)); 
        setText('p1-sc', me.sc); 
        setText('p1-status', getStatusTxt(me.statusList));

        setText('p2-name', op.name); 
        setText('p2-hp-text', `${op.hp} / ${op.charData.maxHp}`); 
        setWidth('p2-hp-bar', (op.hp / op.charData.maxHp) * 100); 
        setText('p2-jkp', getJkpText(op)); 
        setText('p2-sc', op.sc); 
        setText('p2-status', getStatusTxt(op.statusList));
    },
    createCardElement: (card, isHidden = false, onClick = null) => {
        const div = document.createElement('div'); div.className = `card card-${card.type}`;
        if (isHidden) { div.style.background = '#333'; div.style.border = '2px solid #555'; return div; }
        let icon='',label='',modeMark='';
        if(card.type==='blank'){icon='âš”ï¸';label='é€šå¸¸';} if(card.type==='skill'){icon='âš¡';label='ã‚¹ã‚­ãƒ«';} if(card.type==='joker'){icon='ğŸƒ';label='JOKER';} if(card.type==='break'){icon='ğŸ›‘';label='BREAK';}
        if(card.mode==='defense')modeMark='ğŸ›¡ï¸';
        div.innerHTML=`<div class="card-top">${card.value===0?'âˆ':card.value}</div><div class="card-center">${icon}${modeMark}</div><div class="card-name">${label}</div>`;
        if(onClick) div.onclick = onClick;
        return div;
    },
    renderHand: (player, isPlayerControlled, callback) => {
        const container = document.getElementById('p1-hand-view'); 
        container.innerHTML = '';
        player.hand.forEach((card, index) => {
            let isPlayable = true;
            if(card.type === CARD_TYPE.JOKER) {
                if (player.charData.id === 'madan') {
                    let bullets = getStatusVal(player, 'é­”å¼¾');
                    if (bullets === 0 || player.jkp < bullets) isPlayable = false;
                } else {
                    if (player.jkp < player.charData.jkpCost) isPlayable = false;
                }
            }
            if(card.type === CARD_TYPE.SKILL && player.sc > 0) isPlayable = false;
            const cardEl = ui.createCardElement(card, false, () => {
                if (isPlayerControlled && isPlayable && callback) callback(index);
            });
            if (isPlayerControlled && !isPlayable) cardEl.classList.add('disabled');
            container.appendChild(cardEl);
        });
    },
    clearBattleField: () => { document.getElementById('p1-play-card').innerHTML = ''; document.getElementById('p2-play-card').innerHTML = ''; },
    showBattleCards: (c1, c2) => {
        const myCard = myRole === 'p1' ? c1 : c2;
        const opCard = myRole === 'p1' ? c2 : c1;
        const b1 = document.getElementById('p1-play-card'); 
        const b2 = document.getElementById('p2-play-card');
        b1.innerHTML = ''; b2.innerHTML = ''; b1.appendChild(ui.createCardElement(myCard)); b2.appendChild(ui.createCardElement(opCard));
    },
    showModal: (title, buttons) => {
        return new Promise(resolve => {
            document.getElementById('modal-title').textContent = title;
            const btnArea = document.getElementById('modal-buttons'); btnArea.innerHTML = '';
            document.getElementById('modal-overlay').style.display = 'flex';
            if (buttons.length === 0) return; 
            buttons.forEach(btn => {
                const b = document.createElement('button'); b.textContent = btn.label; b.className = `btn ${btn.class||''}`;
                b.onclick = () => { document.getElementById('modal-overlay').style.display = 'none'; resolve(btn.value); };
                btnArea.appendChild(b);
            });
        });
    },
    hideModal: () => { document.getElementById('modal-overlay').style.display = 'none'; },
    wait: (ms) => new Promise(r => setTimeout(r, ms))
};

// ==========================================
// ãƒ¡ã‚¤ãƒ³å‡¦ç†
// ==========================================
function initCharSelect() {
    const list = document.getElementById('char-list');
    list.innerHTML = '';
    for (const key in CHARACTERS) {
        const c = CHARACTERS[key];
        const card = document.createElement('div'); card.className = 'char-select-card';
        let jkpCostText = (key === 'madan') ? "å¼¾æ•°ã¨åŒé‡" : c.jkpCost;
        card.innerHTML = `<div class="char-icon">${c.icon}</div><div class="char-name">${c.name}</div><div class="char-stats"><span class="stat-label">HP:</span> ${c.maxHp} <br><span class="stat-label">JKP:</span> ${jkpCostText} / <span class="stat-label">SC:</span> ${c.scMax}<br>${c.description}</div><div style="margin-top:10px; font-weight:bold; color:#0e639c;">CLICK TO START</div>`;
        card.onclick = () => joinGame(key);
        list.appendChild(card);
    }
}

function joinGame(charKey) {
    startBGM();

    myCharId = charKey;
    document.getElementById('char-list').style.display = 'none';
    document.getElementById('status-msg').style.display = 'none';
    document.getElementById('wait-msg').style.display = 'block';
    socket.emit('join_game', charKey);
}

socket.on('waiting', (msg) => { document.getElementById('wait-msg').textContent = msg; });

socket.on('game_start', (data) => {
    myRole = data.role;
    opponentCharId = data.opponentChar;
    opponentMoveMailbox = {}; 
    startGame();
});

socket.on('opponent_left', () => { alert('å¯¾æˆ¦ç›¸æ‰‹ãŒåˆ‡æ–­ã—ã¾ã—ãŸ'); location.reload(); });

socket.on('opponent_move', (data) => {
    opponentMoveMailbox[data.turn] = data;
    console.log("Received opponent move for turn", data.turn);
});

async function startGame() {
    ui.showGameScreen();
    ui.print("=== BATTLE START ===", 'c-sys');
    
    game = new Game(myCharId, opponentCharId);
    let myPlayer = (myRole === 'p1') ? game.p1 : game.p2;

    while (game.p1.hp > 0 && game.p2.hp > 0) {
        game.turn++;
        game.p1.drawHand(); game.p2.drawHand();
        ui.updateStatus(game.p1, game.p2);
        ui.clearBattleField();
        ui.print(`--- TURN ${game.turn} ---`, 'c-sys');

        const myCardIndex = await selectCardGUI(myPlayer, game);
        const myCardData = myPlayer.hand[myCardIndex];
        
        ui.print("é€šä¿¡ä¸­: ç›¸æ‰‹ã®å…¥åŠ›ã‚’å¾…ã£ã¦ã„ã¾ã™...");
        ui.showModal("é€šä¿¡ä¸­...", []); 
        socket.emit('submit_card', { 
            turn: game.turn, 
            cardIndex: myCardIndex, 
            cardType: myCardData.type,
            cardValue: myCardData.value,
            cardMode: myCardData.mode
        });

        const opponentCardData = await waitForOpponentCard(game.turn);

        ui.hideModal();

        let opPlayer = (myRole === 'p1') ? game.p2 : game.p1;
        let opCard = new Card(opponentCardData.cardType, opponentCardData.cardValue);
        opCard.mode = opponentCardData.cardMode;
        opPlayer.hand[opponentCardData.cardIndex] = opCard;

        const p1Index = (myRole === 'p1') ? myCardIndex : opponentCardData.cardIndex;
        const p2Index = (myRole === 'p1') ? opponentCardData.cardIndex : myCardIndex;
        
        await game.resolveBattle(game.p1.hand[p1Index], game.p2.hand[p2Index]);
        ui.updateStatus(game.p1, game.p2);

        if (game.p1.hp <= 0 || game.p2.hp <= 0) break;

        game.p1.jkp++; game.p2.jkp++;
        if(game.p1.sc > 0) game.p1.sc--;
        if(game.p2.sc > 0) game.p2.sc--;

        [game.p1, game.p2].forEach(p => {
            p.statusList.forEach(s => s.onTurnEnd(p));
            p.statusList = p.statusList.filter(s => !s.isExpired());
        });
        ui.updateStatus(game.p1, game.p2);
        
        await ui.showModal("ã‚¿ãƒ¼ãƒ³çµ‚äº†", [{ label: "æ¬¡ã¸", value: "next" }]);
    }

    ui.print("=== GAME SET ===", 'c-sys');
    
    if (game.p1.hp <= 0 && game.p2.hp <= 0) {
        await ui.showModal("DRAW GAME", [{ label: "ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹", value: "retry" }]);
    } else {
        const winner = game.p1.hp > 0 ? game.p1 : game.p2;
        const isWin = (winner === myPlayer);
        await ui.showModal(isWin ? "YOU WIN!" : "YOU LOSE...", [{ label: "ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹", value: "retry" }]);
    }
    location.reload();
}

function selectCardGUI(player, game) {
    return new Promise(resolve => {
        ui.print(`ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³: ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„`, 'c-sys');
        ui.renderHand(player, true, async (index) => {
            const card = player.hand[index];
            if (card.type === CARD_TYPE.BLANK) {
                const mode = await ui.showModal("ãƒ¢ãƒ¼ãƒ‰é¸æŠ", [{ label: "âš”ï¸ æ”»æ’ƒ", value: "attack", class: "btn-atk" }, { label: "ğŸ›¡ï¸ é˜²å¾¡", value: "defense", class: "btn-def" }]);
                card.mode = (mode === 'defense') ? CARD_MODE.DEFENSE : CARD_MODE.ATTACK;
            }
            document.getElementById('p1-hand-view').innerHTML = ''; 
            resolve(index);
        });
    });
}

function waitForOpponentCard(turn) {
    return new Promise(resolve => {
        if (opponentMoveMailbox[turn]) {
            resolve(opponentMoveMailbox[turn]);
            return;
        }
        const checkInterval = setInterval(() => {
            if (opponentMoveMailbox[turn]) {
                clearInterval(checkInterval);
                resolve(opponentMoveMailbox[turn]);
            }
        }, 100); 
    });
}

initCharSelect();
</script>
</body>
</html>

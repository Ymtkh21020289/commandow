<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Card Game Battle GUI</title>
    <style>
        /* --- å…¨ä½“ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ --- */
        body {
            background-color: #202020;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* å·¦å´ï¼šã‚²ãƒ¼ãƒ ç›¤é¢ (70%) */
        #game-area {
            flex: 7;
            display: flex;
            flex-direction: column;
            border-right: 2px solid #444;
            background: radial-gradient(circle at center, #2a2a2a, #1a1a1a);
            position: relative;
        }

        /* å³å´ï¼šãƒ­ã‚°è¡¨ç¤º (30%) */
        #log-area {
            flex: 3;
            background: #111;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            border-left: 1px solid #333;
        }

        /* --- å„ã‚¨ãƒªã‚¢ã®å®šç¾© --- */
        .player-zone {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }
        
        #battle-zone {
            flex: 1.5;
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            background-color: rgba(0,0,0,0.2);
        }

        /* --- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º --- */
        .status-box {
            width: 80%;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            text-align: center;
        }
        .hp-bar-bg {
            width: 100%;
            height: 15px;
            background: #555;
            border-radius: 10px;
            margin-top: 5px;
            overflow: hidden;
        }
        .hp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #81c784);
            width: 100%;
            transition: width 0.5s ease;
        }
        .status-icons {
            margin-top: 5px;
            font-size: 14px;
            color: #ffcc00;
        }

        /* --- ã‚«ãƒ¼ãƒ‰ã®ãƒ‡ã‚¶ã‚¤ãƒ³ --- */
        .hand-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            perspective: 1000px;
        }

        .card {
            width: 100px;
            height: 140px;
            background: #fff;
            color: #000;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            user-select: none;
        }

        .card:hover {
            transform: translateY(-15px) scale(1.05);
            box-shadow: 0 10px 15px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .card.disabled {
            filter: grayscale(100%) brightness(0.5);
            cursor: not-allowed;
            pointer-events: none;
        }

        /* ã‚«ãƒ¼ãƒ‰ã®ç¨®é¡ã”ã¨ã®è‰²åˆ†ã‘ */
        .card-blank { border: 2px solid #ccc; background: linear-gradient(135deg, #fff, #f0f0f0); }
        .card-skill { border: 2px solid #ffd700; background: linear-gradient(135deg, #fff, #fffde7); }
        .card-joker { border: 2px solid #9c27b0; background: linear-gradient(135deg, #f3e5f5, #e1bee7); color: #4a148c; }
        .card-break { border: 2px solid #00bcd4; background: linear-gradient(135deg, #e0f7fa, #b2ebf2); color: #006064; }

        .card-top { font-size: 18px; font-weight: bold; }
        .card-center { font-size: 32px; text-align: center; margin-top: 10px; }
        .card-bottom { font-size: 12px; text-align: right; }
        
        .card-name {
            font-size: 10px;
            text-align: center;
            color: #555;
            font-weight: bold;
        }

        /* --- ãƒ¢ãƒ¼ãƒ€ãƒ« (æ”»æ’ƒ/é˜²å¾¡é¸æŠãªã©) --- */
        #modal-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal-content {
            background: #333;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid #777;
        }
        .btn {
            background: #0e639c; color: white; border: none; padding: 10px 20px;
            margin: 5px; cursor: pointer; border-radius: 4px; font-size: 16px;
        }
        .btn:hover { background: #1177bb; }
        .btn-atk { background: #d32f2f; }
        .btn-def { background: #1976d2; }

        /* ãƒ­ã‚°ã®è£…é£¾ */
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .c-p1 { color: #64b5f6; }
        .c-p2 { color: #e57373; }
        .c-sys { color: #81c784; }
        .c-dmg { color: #ffb74d; font-weight: bold; }
    </style>
</head>
<body>

    <div id="game-area">
        <div class="player-zone" id="p2-zone">
            <div class="status-box">
                <div id="p2-name">Player 2</div>
                <div class="hp-bar-bg"><div id="p2-hp-bar" class="hp-bar-fill"></div></div>
                <div id="p2-hp-text">HP: 36/36</div>
                <div id="p2-status" class="status-icons"></div>
                <div>JKP: <span id="p2-jkp">0</span></div>
            </div>
            <div class="hand-container" id="p2-hand-view" style="opacity: 0.7; transform: scale(0.8);"></div>
        </div>

        <div id="battle-zone">
            <div id="battle-msg" style="position:absolute; color:#aaa;">BATTLE FIELD</div>
            <div id="p1-play-card"></div>
            <div style="font-size:30px; font-weight:bold;">VS</div>
            <div id="p2-play-card"></div>
        </div>

        <div class="player-zone" id="p1-zone">
            <div class="hand-container" id="p1-hand-view"></div>
            
            <div class="status-box" style="margin-top: 20px;">
                <div id="p1-name">Player 1</div>
                <div class="hp-bar-bg"><div id="p1-hp-bar" class="hp-bar-fill"></div></div>
                <div id="p1-hp-text">HP: 20/20</div>
                <div id="p1-status" class="status-icons"></div>
                <div>JKP: <span id="p1-jkp">0</span></div>
            </div>
        </div>

        <div id="modal-overlay">
            <div class="modal-content">
                <h3 id="modal-title">é¸æŠã—ã¦ãã ã•ã„</h3>
                <div id="modal-buttons"></div>
            </div>
        </div>
    </div>

    <div id="log-area">
        <div style="text-align:center; color:#888; border-bottom:1px solid #555; margin-bottom:10px;">BATTLE LOG</div>
        <div id="logs"></div>
    </div>

<script>
// ==========================================
// GUIåˆ¶å¾¡ & ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
// ==========================================
const ui = {
    logs: document.getElementById('logs'),
    p1Name: document.getElementById('p1-name'),
    p1HpBar: document.getElementById('p1-hp-bar'),
    p1HpText: document.getElementById('p1-hp-text'),
    p1Jkp: document.getElementById('p1-jkp'),
    p1Status: document.getElementById('p1-status'),
    p1Hand: document.getElementById('p1-hand-view'),

    p2Name: document.getElementById('p2-name'),
    p2HpBar: document.getElementById('p2-hp-bar'),
    p2HpText: document.getElementById('p2-hp-text'),
    p2Jkp: document.getElementById('p2-jkp'),
    p2Status: document.getElementById('p2-status'),
    p2Hand: document.getElementById('p2-hand-view'),

    battleP1: document.getElementById('p1-play-card'),
    battleP2: document.getElementById('p2-play-card'),
    modal: document.getElementById('modal-overlay'),
    modalTitle: document.getElementById('modal-title'),
    modalBtns: document.getElementById('modal-buttons'),

    print: (text, type = '') => {
        const div = document.createElement('div');
        div.textContent = text;
        div.className = 'log-entry ' + type;
        ui.logs.appendChild(div);
        ui.logs.scrollTop = ui.logs.scrollHeight;
    },

    updateStatus: (p1, p2) => {
        // P1 Update
        ui.p1Name.textContent = p1.name;
        ui.p1HpText.textContent = `${p1.hp} / ${p1.charData.maxHp}`;
        ui.p1HpBar.style.width = `${(p1.hp / p1.charData.maxHp) * 100}%`;
        ui.p1Jkp.textContent = p1.jkp;
        ui.p1Status.textContent = p1.statusList.map(s => 
            s.name === 'è² å‚·' ? `ğŸ©¸è² å‚·(å¨${s.val1}/æ®‹${s.val2})` : `â˜ ï¸æ­»æ¯’(${s.val1})`
        ).join(' ');

        // P2 Update
        ui.p2Name.textContent = p2.name;
        ui.p2HpText.textContent = `${p2.hp} / ${p2.charData.maxHp}`;
        ui.p2HpBar.style.width = `${(p2.hp / p2.charData.maxHp) * 100}%`;
        ui.p2Jkp.textContent = p2.jkp;
        ui.p2Status.textContent = p2.statusList.map(s => 
            s.name === 'è² å‚·' ? `ğŸ©¸è² å‚·(å¨${s.val1}/æ®‹${s.val2})` : `â˜ ï¸æ­»æ¯’(${s.val1})`
        ).join(' ');
    },

    createCardElement: (card, isHidden = false, onClick = null) => {
        const div = document.createElement('div');
        div.className = `card card-${card.type}`;
        
        if (isHidden) {
            div.style.background = '#333';
            div.style.border = '2px solid #555';
            return div;
        }

        let icon = '';
        let label = '';
        if (card.type === 'blank') { icon = 'âš”ï¸'; label = 'é€šå¸¸'; }
        if (card.type === 'skill') { icon = 'âš¡'; label = 'ã‚¹ã‚­ãƒ«'; }
        if (card.type === 'joker') { icon = 'ğŸƒ'; label = 'JOKER'; }
        if (card.type === 'break') { icon = 'ğŸ›‘'; label = 'BREAK'; }

        // Modeè¡¨ç¤º (æ”»æ’ƒ/é˜²å¾¡)
        let modeMark = '';
        if (card.mode === 'defense') modeMark = 'ğŸ›¡ï¸';

        div.innerHTML = `
            <div class="card-top">${card.value === 0 ? 'âˆ' : card.value}</div>
            <div class="card-center">${icon}${modeMark}</div>
            <div class="card-name">${label}</div>
        `;

        if (onClick) {
            div.onclick = onClick;
        }
        return div;
    },

    renderHand: (player, isPlayerControlled, callback) => {
        const container = isPlayerControlled ? ui.p1Hand : ui.p2Hand;
        container.innerHTML = '';
        player.hand.forEach((card, index) => {
            const isPlayable = isPlayerControlled ? 
                !(card.type === 'joker' && player.jkp < player.charData.jkpCost) : true;
            
            const cardEl = ui.createCardElement(card, !isPlayerControlled, () => {
                if (isPlayerControlled && isPlayable && callback) callback(index);
            });

            if (isPlayerControlled && !isPlayable) cardEl.classList.add('disabled');
            container.appendChild(cardEl);
        });
    },

    clearBattleField: () => {
        ui.battleP1.innerHTML = '';
        ui.battleP2.innerHTML = '';
    },

    showBattleCards: (c1, c2) => {
        ui.battleP1.innerHTML = '';
        ui.battleP2.innerHTML = '';
        ui.battleP1.appendChild(ui.createCardElement(c1));
        ui.battleP2.appendChild(ui.createCardElement(c2));
    },

    showModal: (title, buttons) => {
        return new Promise(resolve => {
            ui.modalTitle.textContent = title;
            ui.modalBtns.innerHTML = '';
            ui.modal.style.display = 'flex';
            
            buttons.forEach(btn => {
                const b = document.createElement('button');
                b.textContent = btn.label;
                b.className = `btn ${btn.class || ''}`;
                b.onclick = () => {
                    ui.modal.style.display = 'none';
                    resolve(btn.value);
                };
                ui.modalBtns.appendChild(b);
            });
        });
    },
    
    wait: (ms) => new Promise(r => setTimeout(r, ms))
};


// ==========================================
// ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ (V4ãƒ™ãƒ¼ã‚¹ + GUIçµåˆ)
// ==========================================

const CARD_TYPE = { BLANK: 'blank', SKILL: 'skill', JOKER: 'joker', SPELL_BREAK: 'break' };
const CARD_MODE = { ATTACK: 'attack', DEFENSE: 'defense' };

class Card {
    constructor(type) {
        this.type = type;
        this.value = 0;
        this.mode = CARD_MODE.ATTACK;
        this.initValue();
    }
    initValue() {
        if (this.type === CARD_TYPE.BLANK || this.type === CARD_TYPE.SKILL) this.value = Math.floor(Math.random() * 13) + 1;
        else if (this.type === CARD_TYPE.JOKER) this.value = 14;
        else if (this.type === CARD_TYPE.SPELL_BREAK) this.value = 0;
    }
    toString() {
        let modeStr = (this.type === CARD_TYPE.BLANK) ? `(${this.mode === CARD_MODE.ATTACK ? 'æ”»' : 'é˜²'})` : '';
        return `[${this.type}${modeStr}:${this.value}]`;
    }
}

class StatusEffect {
    constructor(name, type, value1, value2 = null) {
        this.name = name; this.type = type; this.val1 = value1; this.val2 = value2;
    }
    onTurnEnd(owner) {
        if (this.name === 'æ­»æ¯’') {
            const dmg = 2;
            ui.print(`â˜ ï¸ [æ­»æ¯’] ${owner.name}ã«${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸`, 'c-dmg');
            owner.receiveDamage(dmg);
            this.val1 -= 1;
        }
    }
    onTakeDamage(owner) {
        if (this.name === 'è² å‚·' && this.val2 > 0) {
            ui.print(`ğŸ©¸ [è² å‚·] è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸ ${this.val1}!`, 'c-dmg');
            owner.hp -= this.val1;
            this.val2 -= 1;
        }
    }
    isExpired() {
        if (this.name === 'æ­»æ¯’') return this.val1 <= 0;
        if (this.name === 'è² å‚·') return this.val2 <= 0;
        return false;
    }
}

const CHARACTERS = {
    berserker: {
        name: "ãƒãƒ¼ã‚µãƒ¼ã‚«ãƒ¼", maxHp: 20, jkpCost: 8,
        passive: (p, type, data) => {
            if (type === 'attack_hit' && data.card.type === CARD_TYPE.BLANK) {
                ui.print(`ğŸ”¥ [ãƒ‘ãƒƒã‚·ãƒ–] JKP+1`);
                p.jkp += 1;
            }
        },
        skillEffect: (me, op, val) => {
            ui.print(`âš”ï¸ [ã‚¹ã‚­ãƒ«] åŒæ’ƒ!`, 'c-p1');
            op.receiveDamage(2); op.receiveDamage(2);
            op.addStatus(new StatusEffect('è² å‚·', 'debuff', 1, 1));
        },
        jokerEffect: (me, op) => {
            ui.print(`ğŸ‘¹ [JOKER] æ€ªåŠ›ä¹±ç¥!`, 'c-p1');
            op.addStatus(new StatusEffect('è² å‚·', 'debuff', 1, 20));
            op.receiveDamage(2);
        }
    },
    venom: {
        name: "ãƒ´ã‚§ãƒãƒ ", maxHp: 36, jkpCost: 0,
        passive: (p, type, data) => {
            if (type === 'attack_hit' && data.card.type === CARD_TYPE.BLANK) {
                ui.print(`ğŸ§ª [ãƒ‘ãƒƒã‚·ãƒ–] æ­»æ¯’+2`);
                data.opponent.addStatus(new StatusEffect('æ­»æ¯’', 'debuff', 2));
            }
        },
        skillEffect: (me, op, val) => {
            ui.print(`ğŸŒ«ï¸ [ã‚¹ã‚­ãƒ«] ãƒã‚¤ã‚ºãƒ³ãƒŸã‚¹ãƒˆ!`, 'c-p2');
            op.addStatus(new StatusEffect('æ­»æ¯’', 'debuff', 5));
        },
        jokerEffect: (me, op) => {
            ui.print(`ğŸ’‰ [JOKER] ã‚ªãƒ¼ãƒãƒ¼ãƒ‰ãƒ¼ã‚º!`, 'c-p2');
            let idx = op.statusList.findIndex(s => s.name === 'æ­»æ¯’');
            if (idx !== -1) {
                let poison = op.statusList[idx];
                let dmg = Math.floor(poison.val1 / 2);
                let heal = Math.floor(dmg / 2);
                ui.print(`æ¯’å¸å: ${dmg}ãƒ€ãƒ¡, ${heal}å›å¾©`, 'c-dmg');
                op.receiveDamage(dmg);
                me.hp += heal;
                op.statusList.splice(idx, 1);
            }
        }
    }
};

class Player {
    constructor(charKey) {
        this.charData = CHARACTERS[charKey];
        this.name = this.charData.name;
        this.hp = this.charData.maxHp;
        this.jkp = 0;
        this.hand = [];
        this.statusList = [];
    }
    drawHand() {
        this.hand = [];
        this.hand.push(new Card(CARD_TYPE.BLANK));
        this.hand.push(new Card(CARD_TYPE.BLANK));
        this.hand.push(new Card(CARD_TYPE.SKILL));
        this.hand.push(new Card(CARD_TYPE.JOKER));
        this.hand.push(new Card(CARD_TYPE.SPELL_BREAK));
    }
    addStatus(ef) {
        let exist = this.statusList.find(e => e.name === ef.name);
        if (exist) {
            if (exist.name === 'æ­»æ¯’') exist.val1 += ef.val1;
            else if (exist.name === 'è² å‚·') { exist.val1 += ef.val1; exist.val2 += ef.val2; }
        } else this.statusList.push(ef);
    }
    receiveDamage(amount) {
        this.statusList.forEach(s => s.onTakeDamage(this, amount));
        this.statusList = this.statusList.filter(s => !s.isExpired());
        this.hp -= amount;
        if (this.hp < 0) this.hp = 0;
    }
}

class Game {
    constructor(p1Key, p2Key) {
        this.p1 = new Player(p1Key);
        this.p2 = new Player(p2Key);
        this.turn = 1;
    }

    async resolveBattle(p1CardIndex, p2CardIndex) {
        const c1 = this.p1.hand[p1CardIndex];
        const c2 = this.p2.hand[p2CardIndex];

        // ã‚«ãƒ¼ãƒ‰ã‚’ä¸­å¤®ã«è¡¨ç¤º
        ui.showBattleCards(c1, c2);
        ui.print(`âš”ï¸ ãƒãƒˆãƒ«åˆ¤å®š...`);
        await ui.wait(800);

        let winner = null;
        let isBreakVictory = false;

        // å‹æ•—åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
        if (c1.type === CARD_TYPE.SPELL_BREAK && c2.type === CARD_TYPE.JOKER) winner = this.p1;
        else if (c2.type === CARD_TYPE.SPELL_BREAK && c1.type === CARD_TYPE.JOKER) winner = this.p2;
        else if (c1.type === CARD_TYPE.SPELL_BREAK) { winner = this.p2; isBreakVictory = true; }
        else if (c2.type === CARD_TYPE.SPELL_BREAK) { winner = this.p1; isBreakVictory = true; }
        else {
            if (c1.value > c2.value) winner = this.p1;
            else if (c2.value > c1.value) winner = this.p2;
            else {
                const p1Def = (c1.mode === CARD_MODE.DEFENSE);
                const p2Def = (c2.mode === CARD_MODE.DEFENSE);
                if (p1Def && !p2Def) winner = this.p1;
                else if (!p1Def && p2Def) winner = this.p2;
            }
        }

        if (winner) {
            const loser = (winner === this.p1) ? this.p2 : this.p1;
            const winCard = (winner === this.p1) ? c1 : c2;
            ui.print(`ğŸ… å‹è€…: ${winner.name}`, 'c-sys');
            
            if (isBreakVictory) {
                ui.print(`âš¡ ã‚¹ãƒšãƒ«ãƒ–ãƒ¬ã‚¤ã‚¯å¤±æ•—! åå‹•ãƒ€ãƒ¡ãƒ¼ã‚¸!`, 'c-dmg');
                loser.receiveDamage(1);
            }
            this.applyCardEffect(winner, loser, winCard);
        } else {
            ui.print("Draw (å¼•ãåˆ†ã‘)", 'c-sys');
        }
    }

    applyCardEffect(winner, loser, card) {
        if (card.type === CARD_TYPE.BLANK && card.mode === CARD_MODE.ATTACK) {
             if (winner.charData.passive) winner.charData.passive(winner, 'attack_hit', { opponent: loser, card: card });
        }
        switch (card.type) {
            case CARD_TYPE.BLANK:
                if (card.mode === CARD_MODE.ATTACK) {
                    ui.print(`ğŸ‘Š é€šå¸¸æ”»æ’ƒ (å¨åŠ›:2)`, 'c-dmg');
                    loser.receiveDamage(2);
                } else {
                    ui.print(`ğŸ›¡ï¸ é˜²å¾¡æˆåŠŸ`);
                }
                break;
            case CARD_TYPE.SKILL:
                winner.charData.skillEffect(winner, loser, card.value);
                break;
            case CARD_TYPE.JOKER:
                winner.jkp -= winner.charData.jkpCost;
                winner.charData.jokerEffect(winner, loser);
                break;
            case CARD_TYPE.SPELL_BREAK:
                ui.print(`âœ¨ ã‚¹ãƒšãƒ«ãƒ–ãƒ¬ã‚¤ã‚¯æˆåŠŸ`);
                break;
        }
    }
}

// ==========================================
// ãƒ¡ã‚¤ãƒ³åˆ¶å¾¡ãƒ«ãƒ¼ãƒ— (GUIå¯¾å¿œç‰ˆ)
// ==========================================

async function selectCardGUI(player, game, isPlayerControlled) {
    if (!isPlayerControlled) {
        // ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿(P2)ã¯ãƒ©ãƒ³ãƒ€ãƒ 
        await ui.wait(500); // æ€è€ƒæ™‚é–“æ¼”å‡º
        let validIndexes = [];
        player.hand.forEach((c, i) => {
            if (game.isCardPlayable(player, i)) validIndexes.push(i);
        });
        const choice = validIndexes[Math.floor(Math.random() * validIndexes.length)];
        
        // é€šå¸¸ã‚«ãƒ¼ãƒ‰ãªã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«æ”»é˜²
        if (player.hand[choice].type === CARD_TYPE.BLANK) {
            if (Math.random() > 0.5) player.hand[choice].mode = CARD_MODE.DEFENSE;
        }
        return choice;
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼(P1)ã®å…¥åŠ›å¾…ã¡
    return new Promise(resolve => {
        ui.print(`ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³: ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„`, 'c-sys');
        ui.renderHand(player, true, async (index) => {
            // ã‚«ãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯æ™‚ã®å‡¦ç†
            const card = player.hand[index];
            
            if (card.type === CARD_TYPE.BLANK) {
                // æ”»æ’ƒã‹é˜²å¾¡ã‹é¸ã¶
                const mode = await ui.showModal("ãƒ¢ãƒ¼ãƒ‰é¸æŠ", [
                    { label: "âš”ï¸ æ”»æ’ƒ", value: "attack", class: "btn-atk" },
                    { label: "ğŸ›¡ï¸ é˜²å¾¡", value: "defense", class: "btn-def" }
                ]);
                card.mode = (mode === 'defense') ? CARD_MODE.DEFENSE : CARD_MODE.ATTACK;
            }
            
            // é¸æŠå®Œäº†å¾Œã¯æ‰‹æœ­ã‚’ã‚¯ãƒªãƒƒã‚¯ä¸å¯ã«ã™ã‚‹ãªã©UIæ›´æ–°
            ui.p1Hand.innerHTML = ''; 
            resolve(index);
        });
    });
}

// ç°¡æ˜“çš„ãªPlayableåˆ¤å®šï¼ˆã‚²ãƒ¼ãƒ ã‚¯ãƒ©ã‚¹å†…ã‹ã‚‰åˆ‡ã‚Šå‡ºã—ï¼‰
Game.prototype.isCardPlayable = function(player, index) {
    const card = player.hand[index];
    if (card.type === CARD_TYPE.JOKER && player.jkp < player.charData.jkpCost) return false;
    return true;
};

async function main() {
    ui.print("=== BATTLE START ===", 'c-sys');
    const game = new Game('berserker', 'venom');
    
    // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
    while (game.p1.hp > 0 && game.p2.hp > 0) {
        // ã‚¿ãƒ¼ãƒ³é–‹å§‹
        game.turn++;
        game.p1.drawHand();
        game.p2.drawHand();
        ui.updateStatus(game.p1, game.p2);
        ui.clearBattleField();
        ui.print(`--- TURN ${game.turn} ---`, 'c-sys');

        // ã‚«ãƒ¼ãƒ‰é¸æŠ
        // P2ã®æ‰‹æœ­æç”»(è£é¢)
        ui.renderHand(game.p2, false);

        // åŒæ™‚ã«å‡¦ç†ã—ã¦ã‚‹ã‚ˆã†ã«è¦‹ã›ã‚‹ãŸã‚ã€P1ã®å…¥åŠ›ã‚’å¾…ã¤
        const p1Index = await selectCardGUI(game.p1, game, true);
        ui.print(`P1ãŒã‚«ãƒ¼ãƒ‰ã‚’ã‚»ãƒƒãƒˆ`);
        
        const p2Index = await selectCardGUI(game.p2, game, false);
        ui.print(`P2ãŒã‚«ãƒ¼ãƒ‰ã‚’ã‚»ãƒƒãƒˆ`);

        // ãƒãƒˆãƒ«è§£æ±º
        await game.resolveBattle(p1Index, p2Index);
        ui.updateStatus(game.p1, game.p2);

        if (game.p1.hp <= 0 || game.p2.hp <= 0) break;

        // ã‚¿ãƒ¼ãƒ³çµ‚äº†å‡¦ç†
        game.p1.jkp++; game.p2.jkp++;
        [game.p1, game.p2].forEach(p => {
            p.statusList.forEach(s => s.onTurnEnd(p));
            p.statusList = p.statusList.filter(s => !s.isExpired());
        });
        ui.updateStatus(game.p1, game.p2);
        
        await ui.showModal("ã‚¿ãƒ¼ãƒ³çµ‚äº†", [{ label: "æ¬¡ã¸", value: "next" }]);
    }

    ui.print("=== GAME SET ===", 'c-sys');
    const winnerName = game.p1.hp > 0 ? game.p1.name : game.p2.name;
    await ui.showModal(`å‹è€…: ${winnerName}`, [{ label: "å†æˆ¦", value: "retry" }]);
    location.reload(); // å†èª­ã¿è¾¼ã¿
}

main();

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Card Game Prototype v4</title>
    <style>
        /* é»’ã„ç”»é¢ï¼ˆã‚³ãƒ³ã‚½ãƒ¼ãƒ«ï¼‰é¢¨ã®ãƒ‡ã‚¶ã‚¤ãƒ³ */
        body { background-color: #1e1e1e; color: #d4d4d4; font-family: 'Consolas', 'Monaco', monospace; margin: 0; padding: 20px; display: flex; flex-direction: column; height: 90vh; }
        #game-log { flex: 1; overflow-y: auto; white-space: pre-wrap; margin-bottom: 10px; border: 1px solid #444; padding: 10px; }
        #input-area { display: flex; gap: 10px; }
        #command-input { flex: 1; background: #252526; color: white; border: 1px solid #555; padding: 10px; font-size: 16px; }
        button { background: #0e639c; color: white; border: none; padding: 10px 20px; cursor: pointer; font-size: 16px; }
        button:hover { background: #1177bb; }
        .p1 { color: #9cdcfe; } /* é’ç³» */
        .p2 { color: #ce9178; } /* èµ¤ç³» */
        .system { color: #6a9955; } /* ç·‘ç³» */
    </style>
</head>
<body>

    <div id="game-log"></div>
    
    <div id="input-area">
        <input type="text" id="command-input" placeholder="ã“ã“ã«å…¥åŠ›ã—ã¦Enter..." autocomplete="off">
        <button onclick="submitInput()">é€ä¿¡</button>
    </div>

<script>
// ==========================================
// ãƒ–ãƒ©ã‚¦ã‚¶ç”¨ å…¥å‡ºåŠ›ã‚·ã‚¹ãƒ†ãƒ 
// ==========================================
const logDiv = document.getElementById('game-log');
const inputField = document.getElementById('command-input');
let inputResolver = null;

function print(text, className = '') {
    const span = document.createElement('div');
    span.textContent = text;
    if (className) span.className = className;
    logDiv.appendChild(span);
    logDiv.scrollTop = logDiv.scrollHeight;
}

function ask(question) {
    print(question, 'system');
    return new Promise(resolve => {
        inputResolver = resolve;
        inputField.focus();
    });
}

function submitInput() {
    if (inputResolver) {
        const val = inputField.value;
        print(`> ${val}`);
        inputField.value = '';
        const resolve = inputResolver;
        inputResolver = null;
        resolve(val);
    }
}

inputField.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') submitInput();
});


// ==========================================
// ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ (è² å‚·: å¨åŠ›&å›æ•° åŠ ç®—ç‰ˆ)
// ==========================================

const CARD_TYPE = {
    BLANK: 'blank',
    SKILL: 'skill',
    JOKER: 'joker',
    SPELL_BREAK: 'break'
};

const CARD_MODE = {
    ATTACK: 'attack',
    DEFENSE: 'defense'
};

class Card {
    constructor(type) {
        this.type = type;
        this.value = 0;
        this.mode = CARD_MODE.ATTACK;
        this.initValue();
    }

    initValue() {
        if (this.type === CARD_TYPE.BLANK || this.type === CARD_TYPE.SKILL) {
            this.value = Math.floor(Math.random() * 13) + 1;
        } else if (this.type === CARD_TYPE.JOKER) {
            this.value = 14;
        } else if (this.type === CARD_TYPE.SPELL_BREAK) {
            this.value = 0;
        }
    }

    toString() {
        let modeStr = (this.type === CARD_TYPE.BLANK) ? `(${this.mode === CARD_MODE.ATTACK ? 'æ”»' : 'é˜²'})` : '';
        let valStr = (this.type === CARD_TYPE.SPELL_BREAK) ? "âˆ" : this.value;
        return `[${this.type.toUpperCase()}${modeStr}:${valStr}]`;
    }
}

class StatusEffect {
    constructor(name, type, value1, value2 = null) {
        this.name = name;
        this.type = type;
        this.val1 = value1; // æ­»æ¯’:ã‚¹ã‚¿ãƒƒã‚¯æ•°, è² å‚·:ãƒ€ãƒ¡ãƒ¼ã‚¸é‡
        this.val2 = value2; // è² å‚·:æ®‹ã‚Šå›æ•°
    }
    onTurnEnd(owner) {
        if (this.name === 'æ­»æ¯’') {
            const damage = 2;
            print(`  â˜ ï¸ [æ¯’] ${owner.name}ã«${damage}ãƒ€ãƒ¡ãƒ¼ã‚¸ (æ®‹ã‚¹ã‚¿ãƒƒã‚¯:${this.val1 - 1})`);
            owner.receiveDamage(damage);
            this.val1 -= 1;
        }
    }
    onTakeDamage(owner, damageAmount) {
        if (this.name === 'è² å‚·' && this.val2 > 0) {
            print(`  ğŸ©¸ [è² å‚·] è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸ ${this.val1}! (æ®‹å›æ•°:${this.val2 - 1})`);
            owner.hp -= this.val1;
            this.val2 -= 1;
        }
    }
    isExpired() {
        if (this.name === 'æ­»æ¯’') return this.val1 <= 0;
        if (this.name === 'è² å‚·') return this.val2 <= 0;
        return false;
    }
}

const CHARACTERS = {
    berserker: {
        name: "ãƒãƒ¼ã‚µãƒ¼ã‚«ãƒ¼",
        maxHp: 20,
        scMax: 0,
        jkpCost: 8,
        passive: (player, eventType, data) => {
            if (eventType === 'attack_hit' && data.card.type === CARD_TYPE.BLANK) {
                print(`  ğŸ”¥ [ãƒ‘ãƒƒã‚·ãƒ–] é—˜äº‰æœ¬èƒ½: JKP+1`);
                player.jkp += 1;
            }
        },
        skillEffect: (myself, opponent, cardValue) => {
            print(`  âš”ï¸ [ã‚¹ã‚­ãƒ«] åŒæ’ƒ!`);
            opponent.receiveDamage(2);
            opponent.receiveDamage(2);
            // è² å‚·: ãƒ€ãƒ¡ãƒ¼ã‚¸1, å›æ•°1
            opponent.addStatus(new StatusEffect('è² å‚·', 'debuff', 1, 1));
        },
        jokerEffect: (myself, opponent) => {
            print(`  ğŸ‘¹ [JOKER] æ€ªåŠ›ä¹±ç¥!`);
            // è² å‚·: ãƒ€ãƒ¡ãƒ¼ã‚¸1, å›æ•°20
            opponent.addStatus(new StatusEffect('è² å‚·', 'debuff', 1, 20));
            opponent.receiveDamage(2);
        }
    },
    venom: {
        name: "ãƒ´ã‚§ãƒãƒ ",
        maxHp: 36,
        scMax: 0,
        jkpCost: 0,
        passive: (player, eventType, data) => {
            if (eventType === 'attack_hit' && data.card.type === CARD_TYPE.BLANK) {
                print(`  ğŸ§ª [ãƒ‘ãƒƒã‚·ãƒ–] æ¯’çˆª: æ­»æ¯’+2`);
                data.opponent.addStatus(new StatusEffect('æ­»æ¯’', 'debuff', 2));
            }
        },
        skillEffect: (myself, opponent, cardValue) => {
            print(`  ğŸŒ«ï¸ [ã‚¹ã‚­ãƒ«] ãƒã‚¤ã‚ºãƒ³ãƒŸã‚¹ãƒˆ!`);
            opponent.addStatus(new StatusEffect('æ­»æ¯’', 'debuff', 5));
        },
        jokerEffect: (myself, opponent) => {
            print(`  ğŸ’‰ [JOKER] ã‚ªãƒ¼ãƒãƒ¼ãƒ‰ãƒ¼ã‚º!`);
            let poisonIndex = opponent.statusList.findIndex(s => s.name === 'æ­»æ¯’');
            if (poisonIndex !== -1) {
                let poison = opponent.statusList[poisonIndex];
                let dmg = Math.floor(poison.val1 / 2);
                let heal = Math.floor(dmg / 2);
                print(`  æ¯’å¸å: ${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã€${heal}å›å¾©ã€‚ç›¸æ‰‹ã®æ­»æ¯’ã‚’é™¤å»ï¼`);
                opponent.receiveDamage(dmg);
                myself.hp += heal;
                opponent.statusList.splice(poisonIndex, 1);
            } else {
                print(`  (ç›¸æ‰‹ã«æ¯’ãŒãªã„ãŸã‚åŠ¹æœãªã—)`);
            }
        }
    }
};

class Player {
    constructor(charKey) {
        this.charData = CHARACTERS[charKey];
        this.name = this.charData.name;
        this.hp = this.charData.maxHp;
        this.jkp = 0;
        this.hand = [];
        this.statusList = [];
    }

    drawHand() {
        this.hand = [];
        this.hand.push(new Card(CARD_TYPE.BLANK));
        this.hand.push(new Card(CARD_TYPE.BLANK));
        this.hand.push(new Card(CARD_TYPE.SKILL));
        this.hand.push(new Card(CARD_TYPE.JOKER));
        this.hand.push(new Card(CARD_TYPE.SPELL_BREAK));
    }

    addStatus(newEffect) {
        let existing = this.statusList.find(e => e.name === newEffect.name);
        
        if (existing) {
            if (existing.name === 'æ­»æ¯’') {
                // æ­»æ¯’ã¯ã‚¹ã‚¿ãƒƒã‚¯æ•°(val1)ã‚’åŠ ç®—
                existing.val1 += newEffect.val1;
                print(`  â˜ ï¸ [æ­»æ¯’] ç´¯ç©: ã‚¹ã‚¿ãƒƒã‚¯ãŒ ${existing.val1} ã«ãªã‚Šã¾ã—ãŸ`);
            } 
            else if (existing.name === 'è² å‚·') {
                // â˜…ä¿®æ­£ç®‡æ‰€: è² å‚·ã¯ã€Œå¨åŠ›(val1)ã€ã¨ã€Œå›æ•°(val2)ã€ã®ä¸¡æ–¹ã‚’åŠ ç®—
                existing.val1 += newEffect.val1;
                existing.val2 += newEffect.val2;
                print(`  ğŸ©¸ [è² å‚·] ç´¯ç©: å¨åŠ›ãŒ ${existing.val1} / æ®‹ã‚Šå›æ•°ãŒ ${existing.val2} ã«å¼·åŒ–ã•ã‚Œã¾ã—ãŸ`);
            }
        } else {
            this.statusList.push(newEffect);
        }
    }

    receiveDamage(amount) {
        this.statusList.forEach(s => s.onTakeDamage(this, amount));
        this.statusList = this.statusList.filter(s => !s.isExpired());
        this.hp -= amount;
        if (this.hp < 0) this.hp = 0;
        print(`  > ${this.name} HP: ${this.hp}`);
    }
}

class Game {
    constructor(p1Key, p2Key) {
        this.p1 = new Player(p1Key);
        this.p2 = new Player(p2Key);
        this.turn = 1;
    }

    startTurn() {
        print(`\n================================`, 'system');
        print(`=== ã‚¿ãƒ¼ãƒ³ ${this.turn} é–‹å§‹ ===`, 'system');
        print(`================================`, 'system');
        print(`[P1] ${this.p1.name} (HP:${this.p1.hp}, JKP:${this.p1.jkp})`, 'p1');
        print(`[P2] ${this.p2.name} (HP:${this.p2.hp}, JKP:${this.p2.jkp})`, 'p2');
        this.p1.drawHand();
        this.p2.drawHand();
    }

    isCardPlayable(player, cardIndex) {
        const card = player.hand[cardIndex];
        if (!card) return false;
        
        if (card.type === CARD_TYPE.JOKER && player.jkp < player.charData.jkpCost) {
            print(`ğŸš« JKPä¸è¶³(${player.jkp}/${player.charData.jkpCost})ã®ãŸã‚ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼ã‚’é¸æŠã§ãã¾ã›ã‚“ã€‚`);
            return false;
        }
        return true;
    }

    resolveBattle(p1CardIndex, p2CardIndex) {
        const c1 = this.p1.hand[p1CardIndex];
        const c2 = this.p2.hand[p2CardIndex];

        print(`\nâš”ï¸ ãƒãƒƒãƒçµæœ:`);
        print(`  ${this.p1.name}: ${c1.toString()}`, 'p1');
        print(`  ${this.p2.name}: ${c2.toString()}`, 'p2');

        let winner = null;
        let isBreakVictory = false;

        if (c1.type === CARD_TYPE.SPELL_BREAK && c2.type === CARD_TYPE.JOKER) winner = this.p1;
        else if (c2.type === CARD_TYPE.SPELL_BREAK && c1.type === CARD_TYPE.JOKER) winner = this.p2;
        else if (c1.type === CARD_TYPE.SPELL_BREAK) { winner = this.p2; isBreakVictory = true; }
        else if (c2.type === CARD_TYPE.SPELL_BREAK) { winner = this.p1; isBreakVictory = true; }
        else {
            if (c1.value > c2.value) winner = this.p1;
            else if (c2.value > c1.value) winner = this.p2;
            else {
                const p1Def = (c1.mode === CARD_MODE.DEFENSE);
                const p2Def = (c2.mode === CARD_MODE.DEFENSE);
                if (p1Def && !p2Def) winner = this.p1;
                else if (!p1Def && p2Def) winner = this.p2;
                else winner = null;
            }
        }

        if (winner) {
            const loser = (winner === this.p1) ? this.p2 : this.p1;
            const winCard = (winner === this.p1) ? c1 : c2;
            
            print(`ğŸ… å‹è€…: ${winner.name}`, 'system');

            if (isBreakVictory) {
                print(`  âš¡ ã‚¹ãƒšãƒ«ãƒ–ãƒ¬ã‚¤ã‚¯å¤±æ•—ï¼ ${loser.name}ã¯è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒå¢—åŠ (1)ï¼`);
                loser.receiveDamage(1); 
            }

            this.applyCardEffect(winner, loser, winCard);
        } else {
            print("Draw (å¼•ãåˆ†ã‘ - ä½•ã‚‚èµ·ã“ã‚‰ãªã„)");
        }
    }

    applyCardEffect(winner, loser, card) {
        if (card.type === CARD_TYPE.BLANK && card.mode === CARD_MODE.ATTACK) {
             if (winner.charData.passive) {
                 winner.charData.passive(winner, 'attack_hit', { opponent: loser, card: card });
             }
        }

        switch (card.type) {
            case CARD_TYPE.BLANK:
                if (card.mode === CARD_MODE.ATTACK) {
                    print(`  ğŸ‘Š é€šå¸¸æ”»æ’ƒï¼ å¨åŠ›:2`);
                    loser.receiveDamage(2);
                } else {
                    print(`  ğŸ›¡ï¸ é˜²å¾¡æˆåŠŸï¼ (åŠ¹æœãªã—)`);
                }
                break;
            case CARD_TYPE.SKILL:
                winner.charData.skillEffect(winner, loser, card.value);
                break;
            case CARD_TYPE.JOKER:
                winner.jkp -= winner.charData.jkpCost;
                winner.charData.jokerEffect(winner, loser);
                break;
            case CARD_TYPE.SPELL_BREAK:
                print(`  âœ¨ ã‚¹ãƒšãƒ«ãƒ–ãƒ¬ã‚¤ã‚¯æˆåŠŸï¼ (åŠ¹æœãªã—)`);
                break;
        }
    }

    endTurn() {
        print(`\n--- ã‚¿ãƒ¼ãƒ³çµ‚äº†å‡¦ç† ---`);
        this.p1.jkp += 1;
        this.p2.jkp += 1;
        [this.p1, this.p2].forEach(p => {
            p.statusList.forEach(s => s.onTurnEnd(p));
            p.statusList = p.statusList.filter(s => !s.isExpired());
        });
        this.turn++;
    }

    isGameOver() {
        return this.p1.hp <= 0 || this.p2.hp <= 0;
    }
}

async function selectCard(player, game) {
    while (true) {
        print(`\nã€${player.name} ã®ã‚¿ãƒ¼ãƒ³ã€‘`, player === game.p1 ? 'p1' : 'p2');
        print("æ‰‹æœ­:");
        player.hand.forEach((card, index) => {
            let note = "";
            if (card.type === CARD_TYPE.JOKER && player.jkp < player.charData.jkpCost) {
                note = " (Ã— JKPä¸è¶³)";
            }
            print(`  ${index}: ${card.toString()}${note}`);
        });

        const answer = await ask(`> ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„ (0-4): `);
        const index = parseInt(answer);

        if (isNaN(index) || index < 0 || index >= player.hand.length) {
            print("âš ï¸ ç„¡åŠ¹ãªç•ªå·ã§ã™ã€‚ã‚‚ã†ä¸€åº¦å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
            continue;
        }
        if (!game.isCardPlayable(player, index)) continue;

        const selectedCard = player.hand[index];
        if (selectedCard.type === CARD_TYPE.BLANK) {
            const modeAns = await ask(`> ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„ (a:æ”»æ’ƒ / d:é˜²å¾¡): `);
            if (modeAns.toLowerCase() === 'd') {
                selectedCard.mode = CARD_MODE.DEFENSE;
            } else {
                selectedCard.mode = CARD_MODE.ATTACK;
            }
        }
        return index;
    }
}

async function main() {
    print("=== ã‚«ãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ  ãƒãƒˆãƒ«ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ v4 ===", 'system');
    print("ä¿®æ­£: è² å‚·åŠ¹æœã®é‡è¤‡æ™‚ã€å›æ•°ã¨å¨åŠ›ã‚’åˆç®—", 'system');
    
    const game = new Game('berserker', 'venom');

    while (!game.isGameOver()) {
        game.startTurn();
        const p1Index = await selectCard(game.p1, game);
        print("--------------------------------");
        const p2Index = await selectCard(game.p2, game);
        game.resolveBattle(p1Index, p2Index);
        if (game.isGameOver()) break;
        game.endTurn();
        await ask('\n[Enterã§æ¬¡ã¸]');
    }

    print("\n=== ã‚²ãƒ¼ãƒ ã‚»ãƒƒãƒˆï¼ ===", 'system');
    if (game.p1.hp > 0) print(`å‹è€…: ${game.p1.name} !`, 'p1');
    else if (game.p2.hp > 0) print(`å‹è€…: ${game.p2.name} !`, 'p2');
    else print("å¼•ãåˆ†ã‘ï¼");
}

main();

</script>
</body>
</html>
